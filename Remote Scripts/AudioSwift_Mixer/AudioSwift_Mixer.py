### Script Generated by Control Surface Studio for Python 3 (resorted to default: no)
import Live
from _Framework.ControlSurface import ControlSurface
from _Framework.Layer import Layer
from _Framework.DeviceComponent import DeviceComponent
from _Framework.MixerComponent import MixerComponent
from _Framework.SliderElement import SliderElement
from _Framework.TransportComponent import TransportComponent
from _Framework.InputControlElement import *
from _Framework.ButtonElement import ButtonElement
from _Framework.ButtonMatrixElement import ButtonMatrixElement
from _Framework.SessionComponent import SessionComponent
from _Framework.EncoderElement import *
from Launchpad.ConfigurableButtonElement import ConfigurableButtonElement
import time
from itertools import chain
from _Framework.Util import find_if
import collections
try:
	from .user import *
except ImportError:
	pass
class AudioSwift_Mixer(ControlSurface):
	def __init__(self, c_instance):
		super(AudioSwift_Mixer, self).__init__(c_instance)
		with self.component_guard():
			global _map_modes
			_map_modes = Live.MidiMap.MapMode
			self.current_track_offset = 0
			self.current_scene_offset = 0
			global mixer
			num_tracks = 128
			num_returns = 24
			if hasattr(self, 'modifierList'):
				self.modifierList()
			if hasattr(self, 'customLists'):
				self.customLists()
			self._settings()
			self._inputs()
			self.turn_inputs_off()
			self.mixer = MixerComponent(num_tracks, num_returns)
			global active_mode
			self.debug_on = False
			self.mode_list()
			self.set_active_mode(self.modes[0])
			self.listening_to_tracks()
			self.song().add_tracks_listener(self.listening_to_tracks)
			self.song().add_tracks_listener(self._on_tracks_changed)
			self.song().add_scenes_listener(self._on_scenes_changed)
			self.all_track_device_listeners()
			self.song().view.add_selected_parameter_listener(self._on_selected_parameter_changed)
			self.create_clip_slot_map()
			try:
				self.user = user(self)
			except:
				pass
			self.call_script_reaction(None, None, 'script_was_initialised')
	def modifierList(self):
		global modifiers
		self.modifiers = {}
		self.modifiers["m1"] = {"value": 0}
		self.modifiers["m2"] = {"value": 0}
		self.modifiers["m3"] = {"value": 0}
		self.modifiers["m4"] = {"value": 0}
		self.modifiers["m5"] = {"value": 0}
		self.modifiers["m6"] = {"value": 0}
		self.modifiers["m7"] = {"value": 0}
		self.modifiers["m8"] = {"value": 0}
		self.modifiers["m9"] = {"value": 0}
		self.modifiers["m10"] = {"value": 0}
		self.modifiers["m11"] = {"value": 0}
		self.modifiers["m12"] = {"value": 0}
		self.modifiers["m13"] = {"value": 0}
		self.modifiers["m14"] = {"value": 0}
		self.modifiers["m15"] = {"value": 0}
		self.modifiers["m16"] = {"value": 0}
		self.modifiers["m17"] = {"value": 0}
		self.modifiers["m18"] = {"value": 0}
		self.modifiers["m19"] = {"value": 0}
		self.modifiers["m20"] = {"value": 0}
	def customLists(self):
		global lists
		self.lists = {}
		self.lists["list1"] = {"value": []}
		self.lists["list2"] = {"value": []}
		self.lists["list3"] = {"value": []}
		self.lists["list4"] = {"value": []}
		self.lists["list5"] = {"value": []}
		self.lists["list6"] = {"value": []}
		self.lists["list7"] = {"value": []}
		self.lists["list8"] = {"value": []}
		self.lists["list9"] = {"value": []}
		self.lists["list10"] = {"value": []}
	def _settings(self):
		self.global_feedback = "default"
		self.global_feedback_active = False
		self.global_LED_on = 127
		self.global_LED_off = 0
		self.controller_LED_on = 127
		self.controller_LED_off = 0
		self.led_on = self.controller_LED_on
		self.led_off = self.controller_LED_off
	def mode_list(self):
		global modes
		self.mode_conf = 36975
		self.modes = {}
		self.modes[0] = "1"
	def _inputs(self):
		self.input_map = [
			"midi_cc_ch_14_val_21",
			"midi_cc_ch_14_val_22",
			"midi_cc_ch_14_val_23",
			"midi_cc_ch_14_val_27",
			"midi_cc_ch_14_val_46",
			"midi_cc_ch_14_val_28",
			"midi_cc_ch_14_val_29",
			"midi_cc_ch_14_val_30",
			"midi_cc_ch_14_val_31",
			"midi_cc_ch_14_val_32",
			"midi_cc_ch_14_val_33",
			"midi_cc_ch_14_val_34",
			"midi_cc_ch_14_val_35",
			"midi_cc_ch_14_val_36",
			"midi_cc_ch_14_val_37",
			"midi_cc_ch_14_val_38",
			"midi_cc_ch_14_val_39",
			"midi_cc_ch_14_val_24",
			"midi_cc_ch_14_val_25",
			"midi_cc_ch_14_val_26",
			"midi_cc_ch_14_val_41",
			"midi_cc_ch_14_val_42",
			"midi_cc_ch_14_val_43",
			"midi_cc_ch_14_val_44",
			"midi_cc_ch_14_val_45",
			"midi_cc_ch_14_val_47",
			"midi_cc_ch_14_val_48",
			"midi_cc_ch_14_val_49",
			"midi_cc_ch_14_val_50",
			"midi_cc_ch_14_val_51",
			"midi_cc_ch_14_val_52",
			"midi_cc_ch_14_val_53",
			"midi_cc_ch_14_val_56",
			"midi_cc_ch_14_val_54",
			"midi_cc_ch_14_val_55",
			"midi_cc_ch_14_val_40",
			"midi_cc_ch_14_val_57"]
		self.midi_cc_ch_14_val_21 = EncoderElement(MIDI_CC_TYPE, 14, 21, _map_modes.absolute)
		self.midi_cc_ch_14_val_21.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_21.pre_val = 0
		self.midi_cc_ch_14_val_21.cur_val = 0
		self.midi_cc_ch_14_val_22 = EncoderElement(MIDI_CC_TYPE, 14, 22, _map_modes.absolute)
		self.midi_cc_ch_14_val_22.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_22.pre_val = 0
		self.midi_cc_ch_14_val_22.cur_val = 0
		self.midi_cc_ch_14_val_23 = EncoderElement(MIDI_CC_TYPE, 14, 23, _map_modes.absolute)
		self.midi_cc_ch_14_val_23.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_23.pre_val = 0
		self.midi_cc_ch_14_val_23.cur_val = 0
		self.midi_cc_ch_14_val_27 = EncoderElement(MIDI_CC_TYPE, 14, 27, _map_modes.absolute)
		self.midi_cc_ch_14_val_27.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_27.pre_val = 0
		self.midi_cc_ch_14_val_27.cur_val = 0
		self.midi_cc_ch_14_val_46 = EncoderElement(MIDI_CC_TYPE, 14, 46, _map_modes.absolute)
		self.midi_cc_ch_14_val_46.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_46.pre_val = 0
		self.midi_cc_ch_14_val_46.cur_val = 0
		self.midi_cc_ch_14_val_28 = EncoderElement(MIDI_CC_TYPE, 14, 28, _map_modes.absolute)
		self.midi_cc_ch_14_val_28.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_28.pre_val = 0
		self.midi_cc_ch_14_val_28.cur_val = 0
		self.midi_cc_ch_14_val_29 = EncoderElement(MIDI_CC_TYPE, 14, 29, _map_modes.absolute)
		self.midi_cc_ch_14_val_29.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_29.pre_val = 0
		self.midi_cc_ch_14_val_29.cur_val = 0
		self.midi_cc_ch_14_val_30 = EncoderElement(MIDI_CC_TYPE, 14, 30, _map_modes.absolute)
		self.midi_cc_ch_14_val_30.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_30.pre_val = 0
		self.midi_cc_ch_14_val_30.cur_val = 0
		self.midi_cc_ch_14_val_31 = EncoderElement(MIDI_CC_TYPE, 14, 31, _map_modes.absolute)
		self.midi_cc_ch_14_val_31.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_31.pre_val = 0
		self.midi_cc_ch_14_val_31.cur_val = 0
		self.midi_cc_ch_14_val_32 = EncoderElement(MIDI_CC_TYPE, 14, 32, _map_modes.absolute)
		self.midi_cc_ch_14_val_32.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_32.pre_val = 0
		self.midi_cc_ch_14_val_32.cur_val = 0
		self.midi_cc_ch_14_val_33 = EncoderElement(MIDI_CC_TYPE, 14, 33, _map_modes.absolute)
		self.midi_cc_ch_14_val_33.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_33.pre_val = 0
		self.midi_cc_ch_14_val_33.cur_val = 0
		self.midi_cc_ch_14_val_34 = EncoderElement(MIDI_CC_TYPE, 14, 34, _map_modes.absolute)
		self.midi_cc_ch_14_val_34.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_34.pre_val = 0
		self.midi_cc_ch_14_val_34.cur_val = 0
		self.midi_cc_ch_14_val_35 = EncoderElement(MIDI_CC_TYPE, 14, 35, _map_modes.absolute)
		self.midi_cc_ch_14_val_35.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_35.pre_val = 0
		self.midi_cc_ch_14_val_35.cur_val = 0
		self.midi_cc_ch_14_val_36 = EncoderElement(MIDI_CC_TYPE, 14, 36, _map_modes.absolute)
		self.midi_cc_ch_14_val_36.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_36.pre_val = 0
		self.midi_cc_ch_14_val_36.cur_val = 0
		self.midi_cc_ch_14_val_37 = EncoderElement(MIDI_CC_TYPE, 14, 37, _map_modes.absolute)
		self.midi_cc_ch_14_val_37.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_37.pre_val = 0
		self.midi_cc_ch_14_val_37.cur_val = 0
		self.midi_cc_ch_14_val_38 = EncoderElement(MIDI_CC_TYPE, 14, 38, _map_modes.absolute)
		self.midi_cc_ch_14_val_38.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_38.pre_val = 0
		self.midi_cc_ch_14_val_38.cur_val = 0
		self.midi_cc_ch_14_val_39 = EncoderElement(MIDI_CC_TYPE, 14, 39, _map_modes.absolute)
		self.midi_cc_ch_14_val_39.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_39.pre_val = 0
		self.midi_cc_ch_14_val_39.cur_val = 0
		self.midi_cc_ch_14_val_24 = ConfigurableButtonElement(True, MIDI_CC_TYPE, 14, 24)
		self.midi_cc_ch_14_val_24.set_on_off_values(self.led_on, self.led_off)
		self.midi_cc_ch_14_val_24.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_24.pre_val = 0
		self.midi_cc_ch_14_val_24.cur_val = 0
		self.midi_cc_ch_14_val_25 = ConfigurableButtonElement(True, MIDI_CC_TYPE, 14, 25)
		self.midi_cc_ch_14_val_25.set_on_off_values(self.led_on, self.led_off)
		self.midi_cc_ch_14_val_25.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_25.pre_val = 0
		self.midi_cc_ch_14_val_25.cur_val = 0
		self.midi_cc_ch_14_val_26 = ConfigurableButtonElement(True, MIDI_CC_TYPE, 14, 26)
		self.midi_cc_ch_14_val_26.set_on_off_values(self.led_on, self.led_off)
		self.midi_cc_ch_14_val_26.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_26.pre_val = 0
		self.midi_cc_ch_14_val_26.cur_val = 0
		self.midi_cc_ch_14_val_41 = ConfigurableButtonElement(True, MIDI_CC_TYPE, 14, 41)
		self.midi_cc_ch_14_val_41.set_on_off_values(self.led_on, self.led_off)
		self.midi_cc_ch_14_val_41.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_41.pre_val = 0
		self.midi_cc_ch_14_val_41.cur_val = 0
		self.midi_cc_ch_14_val_42 = ConfigurableButtonElement(True, MIDI_CC_TYPE, 14, 42)
		self.midi_cc_ch_14_val_42.set_on_off_values(self.led_on, self.led_off)
		self.midi_cc_ch_14_val_42.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_42.pre_val = 0
		self.midi_cc_ch_14_val_42.cur_val = 0
		self.midi_cc_ch_14_val_43 = ConfigurableButtonElement(True, MIDI_CC_TYPE, 14, 43)
		self.midi_cc_ch_14_val_43.set_on_off_values(self.led_on, self.led_off)
		self.midi_cc_ch_14_val_43.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_43.pre_val = 0
		self.midi_cc_ch_14_val_43.cur_val = 0
		self.midi_cc_ch_14_val_44 = ConfigurableButtonElement(True, MIDI_CC_TYPE, 14, 44)
		self.midi_cc_ch_14_val_44.set_on_off_values(self.led_on, self.led_off)
		self.midi_cc_ch_14_val_44.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_44.pre_val = 0
		self.midi_cc_ch_14_val_44.cur_val = 0
		self.midi_cc_ch_14_val_45 = ConfigurableButtonElement(True, MIDI_CC_TYPE, 14, 45)
		self.midi_cc_ch_14_val_45.set_on_off_values(self.led_on, self.led_off)
		self.midi_cc_ch_14_val_45.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_45.pre_val = 0
		self.midi_cc_ch_14_val_45.cur_val = 0
		self.midi_cc_ch_14_val_47 = ConfigurableButtonElement(True, MIDI_CC_TYPE, 14, 47)
		self.midi_cc_ch_14_val_47.set_on_off_values(self.led_on, self.led_off)
		self.midi_cc_ch_14_val_47.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_47.pre_val = 0
		self.midi_cc_ch_14_val_47.cur_val = 0
		self.midi_cc_ch_14_val_48 = ConfigurableButtonElement(True, MIDI_CC_TYPE, 14, 48)
		self.midi_cc_ch_14_val_48.set_on_off_values(self.led_on, self.led_off)
		self.midi_cc_ch_14_val_48.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_48.pre_val = 0
		self.midi_cc_ch_14_val_48.cur_val = 0
		self.midi_cc_ch_14_val_49 = ConfigurableButtonElement(True, MIDI_CC_TYPE, 14, 49)
		self.midi_cc_ch_14_val_49.set_on_off_values(self.led_on, self.led_off)
		self.midi_cc_ch_14_val_49.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_49.pre_val = 0
		self.midi_cc_ch_14_val_49.cur_val = 0
		self.midi_cc_ch_14_val_50 = ConfigurableButtonElement(True, MIDI_CC_TYPE, 14, 50)
		self.midi_cc_ch_14_val_50.set_on_off_values(self.led_on, self.led_off)
		self.midi_cc_ch_14_val_50.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_50.pre_val = 0
		self.midi_cc_ch_14_val_50.cur_val = 0
		self.midi_cc_ch_14_val_51 = ConfigurableButtonElement(True, MIDI_CC_TYPE, 14, 51)
		self.midi_cc_ch_14_val_51.set_on_off_values(self.led_on, self.led_off)
		self.midi_cc_ch_14_val_51.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_51.pre_val = 0
		self.midi_cc_ch_14_val_51.cur_val = 0
		self.midi_cc_ch_14_val_52 = ConfigurableButtonElement(True, MIDI_CC_TYPE, 14, 52)
		self.midi_cc_ch_14_val_52.set_on_off_values(self.led_on, self.led_off)
		self.midi_cc_ch_14_val_52.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_52.pre_val = 0
		self.midi_cc_ch_14_val_52.cur_val = 0
		self.midi_cc_ch_14_val_53 = ConfigurableButtonElement(True, MIDI_CC_TYPE, 14, 53)
		self.midi_cc_ch_14_val_53.set_on_off_values(self.led_on, self.led_off)
		self.midi_cc_ch_14_val_53.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_53.pre_val = 0
		self.midi_cc_ch_14_val_53.cur_val = 0
		self.midi_cc_ch_14_val_56 = ConfigurableButtonElement(True, MIDI_CC_TYPE, 14, 56)
		self.midi_cc_ch_14_val_56.set_on_off_values(self.led_on, self.led_off)
		self.midi_cc_ch_14_val_56.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_56.pre_val = 0
		self.midi_cc_ch_14_val_56.cur_val = 0
		self.midi_cc_ch_14_val_54 = ConfigurableButtonElement(True, MIDI_CC_TYPE, 14, 54)
		self.midi_cc_ch_14_val_54.set_on_off_values(self.led_on, self.led_off)
		self.midi_cc_ch_14_val_54.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_54.pre_val = 0
		self.midi_cc_ch_14_val_54.cur_val = 0
		self.midi_cc_ch_14_val_55 = ConfigurableButtonElement(True, MIDI_CC_TYPE, 14, 55)
		self.midi_cc_ch_14_val_55.set_on_off_values(self.led_on, self.led_off)
		self.midi_cc_ch_14_val_55.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_55.pre_val = 0
		self.midi_cc_ch_14_val_55.cur_val = 0
		self.midi_cc_ch_14_val_40 = EncoderElement(MIDI_CC_TYPE, 14, 40, _map_modes.absolute)
		self.midi_cc_ch_14_val_40.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_40.pre_val = 0
		self.midi_cc_ch_14_val_40.cur_val = 0
		self.midi_cc_ch_14_val_57 = EncoderElement(MIDI_CC_TYPE, 14, 57, _map_modes.absolute)
		self.midi_cc_ch_14_val_57.add_value_listener(self.placehold_listener,identify_sender= False)
		self.midi_cc_ch_14_val_57.pre_val = 0
		self.midi_cc_ch_14_val_57.cur_val = 0
	def _mode1_custom_lom_listeners(self, updated_by=False):
		exclude_list = []
		if updated_by not in exclude_list:
			try:
				self.mode1_listener_attach0 = self.song().view
				self.mode1_listener_attach0.add_selected_track_listener(self._mode1_self_song_view_add_selected_track_listener_id_43)
			except:
				pass
		exclude_list = ['_on_tracks_changed']
		if updated_by not in exclude_list:
			try:
				self.mode1_listener_attach1 = self.song()
				self.mode1_listener_attach1.add_tracks_listener(self._mode1_self_song_add_tracks_listener_id_45)
			except:
				pass
		exclude_list = []
		if updated_by not in exclude_list:
			try:
				self.mode1_listener_attach2 = self.song()
				self.mode1_listener_attach2.add_return_tracks_listener(self._mode1_self_song_add_return_tracks_listener_id_45)
			except:
				pass
		exclude_list = []
		if updated_by not in exclude_list:
			try:
				self.mode1_listener_attach3 = self.song().view
				self.mode1_listener_attach3.add_selected_parameter_listener(self._mode1_self_song_view_add_selected_parameter_listener_id_49)
			except:
				pass
		exclude_list = []
		if updated_by not in exclude_list:
			try:
				self.mode1_listener_attach4 = self.song().view.selected_parameter
				self.mode1_listener_attach4.add_name_listener(self._mode1_self_song_view_selected_parameter_add_name_listener_id_49)
			except:
				pass
		exclude_list = []
		if updated_by not in exclude_list:
			try:
				self.mode1_listener_attach5 = self.song()
				self.mode1_listener_attach5.add_is_playing_listener(self._mode1_self_song_add_is_playing_listener_id_41)
			except:
				pass
		return
	def _remove_mode1_custom_lom_listeners(self, updated_by=False):
		exclude_list = []
		if updated_by not in exclude_list:
			try:
				self.mode1_listener_attach0.remove_selected_track_listener(self._mode1_self_song_view_add_selected_track_listener_id_43)
				self.mode1_listener_attach0 = None
			except:
				pass
		exclude_list = ['_on_tracks_changed']
		if updated_by not in exclude_list:
			try:
				self.mode1_listener_attach1.remove_tracks_listener(self._mode1_self_song_add_tracks_listener_id_45)
				self.mode1_listener_attach1 = None
			except:
				pass
		exclude_list = []
		if updated_by not in exclude_list:
			try:
				self.mode1_listener_attach2.remove_return_tracks_listener(self._mode1_self_song_add_return_tracks_listener_id_45)
				self.mode1_listener_attach2 = None
			except:
				pass
		exclude_list = []
		if updated_by not in exclude_list:
			try:
				self.mode1_listener_attach3.remove_selected_parameter_listener(self._mode1_self_song_view_add_selected_parameter_listener_id_49)
				self.mode1_listener_attach3 = None
			except:
				pass
		exclude_list = []
		if updated_by not in exclude_list:
			try:
				self.mode1_listener_attach4.remove_name_listener(self._mode1_self_song_view_selected_parameter_add_name_listener_id_49)
				self.mode1_listener_attach4 = None
			except:
				pass
		exclude_list = []
		if updated_by not in exclude_list:
			try:
				self.mode1_listener_attach5.remove_is_playing_listener(self._mode1_self_song_add_is_playing_listener_id_41)
				self.mode1_listener_attach5 = None
			except:
				pass
		return
	def _mode1(self):
		self.show_message("Mixer Mode is active")
		self.midi_cc_ch_14_val_56.add_value_listener(self.midi_cc_ch_14_val_56_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_55.add_value_listener(self.midi_cc_ch_14_val_55_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_21.add_value_listener(self.midi_cc_ch_14_val_21_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_22.add_value_listener(self.midi_cc_ch_14_val_22_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_57.add_value_listener(self.midi_cc_ch_14_val_57_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_23.add_value_listener(self.midi_cc_ch_14_val_23_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_27.add_value_listener(self.midi_cc_ch_14_val_27_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_24.add_value_listener(self.midi_cc_ch_14_val_24_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_25.add_value_listener(self.midi_cc_ch_14_val_25_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_26.add_value_listener(self.midi_cc_ch_14_val_26_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_46.add_value_listener(self.midi_cc_ch_14_val_46_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_42.add_value_listener(self.midi_cc_ch_14_val_42_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_43.add_value_listener(self.midi_cc_ch_14_val_43_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_44.add_value_listener(self.midi_cc_ch_14_val_44_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_54.add_value_listener(self.midi_cc_ch_14_val_54_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_53.add_value_listener(self.midi_cc_ch_14_val_53_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_48.add_value_listener(self.midi_cc_ch_14_val_48_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_47.add_value_listener(self.midi_cc_ch_14_val_47_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_49.add_value_listener(self.midi_cc_ch_14_val_49_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_50.add_value_listener(self.midi_cc_ch_14_val_50_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_45.add_value_listener(self.midi_cc_ch_14_val_45_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_51.add_value_listener(self.midi_cc_ch_14_val_51_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_52.add_value_listener(self.midi_cc_ch_14_val_52_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_41.add_value_listener(self.midi_cc_ch_14_val_41_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_40.add_value_listener(self.midi_cc_ch_14_val_40_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_28.add_value_listener(self.midi_cc_ch_14_val_28_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_29.add_value_listener(self.midi_cc_ch_14_val_29_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_30.add_value_listener(self.midi_cc_ch_14_val_30_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_31.add_value_listener(self.midi_cc_ch_14_val_31_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_32.add_value_listener(self.midi_cc_ch_14_val_32_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_33.add_value_listener(self.midi_cc_ch_14_val_33_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_34.add_value_listener(self.midi_cc_ch_14_val_34_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_35.add_value_listener(self.midi_cc_ch_14_val_35_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_36.add_value_listener(self.midi_cc_ch_14_val_36_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_37.add_value_listener(self.midi_cc_ch_14_val_37_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_38.add_value_listener(self.midi_cc_ch_14_val_38_mode1_listener,identify_sender= False)
		self.midi_cc_ch_14_val_39.add_value_listener(self.midi_cc_ch_14_val_39_mode1_listener,identify_sender= False)
		self._mode1_configs()
		self._mode1_led_listeners()
		self._add_custom_lom_listeners_handler(1)
	def _remove_mode1(self):
		self.show_message("Mode 1 is removed")
		self.turn_inputs_off()
		self.midi_cc_ch_14_val_56.remove_value_listener(self.midi_cc_ch_14_val_56_mode1_listener)
		self.midi_cc_ch_14_val_55.remove_value_listener(self.midi_cc_ch_14_val_55_mode1_listener)
		self.midi_cc_ch_14_val_21.remove_value_listener(self.midi_cc_ch_14_val_21_mode1_listener)
		self.midi_cc_ch_14_val_22.remove_value_listener(self.midi_cc_ch_14_val_22_mode1_listener)
		self.midi_cc_ch_14_val_57.remove_value_listener(self.midi_cc_ch_14_val_57_mode1_listener)
		self.midi_cc_ch_14_val_23.remove_value_listener(self.midi_cc_ch_14_val_23_mode1_listener)
		self.midi_cc_ch_14_val_27.remove_value_listener(self.midi_cc_ch_14_val_27_mode1_listener)
		self.midi_cc_ch_14_val_24.remove_value_listener(self.midi_cc_ch_14_val_24_mode1_listener)
		self.midi_cc_ch_14_val_25.remove_value_listener(self.midi_cc_ch_14_val_25_mode1_listener)
		self.midi_cc_ch_14_val_26.remove_value_listener(self.midi_cc_ch_14_val_26_mode1_listener)
		self.midi_cc_ch_14_val_46.remove_value_listener(self.midi_cc_ch_14_val_46_mode1_listener)
		self.midi_cc_ch_14_val_42.remove_value_listener(self.midi_cc_ch_14_val_42_mode1_listener)
		self.midi_cc_ch_14_val_43.remove_value_listener(self.midi_cc_ch_14_val_43_mode1_listener)
		self.midi_cc_ch_14_val_44.remove_value_listener(self.midi_cc_ch_14_val_44_mode1_listener)
		self.midi_cc_ch_14_val_54.remove_value_listener(self.midi_cc_ch_14_val_54_mode1_listener)
		self.midi_cc_ch_14_val_53.remove_value_listener(self.midi_cc_ch_14_val_53_mode1_listener)
		self.midi_cc_ch_14_val_48.remove_value_listener(self.midi_cc_ch_14_val_48_mode1_listener)
		self.midi_cc_ch_14_val_47.remove_value_listener(self.midi_cc_ch_14_val_47_mode1_listener)
		self.midi_cc_ch_14_val_49.remove_value_listener(self.midi_cc_ch_14_val_49_mode1_listener)
		self.midi_cc_ch_14_val_50.remove_value_listener(self.midi_cc_ch_14_val_50_mode1_listener)
		self.midi_cc_ch_14_val_45.remove_value_listener(self.midi_cc_ch_14_val_45_mode1_listener)
		self.midi_cc_ch_14_val_51.remove_value_listener(self.midi_cc_ch_14_val_51_mode1_listener)
		self.midi_cc_ch_14_val_52.remove_value_listener(self.midi_cc_ch_14_val_52_mode1_listener)
		self.midi_cc_ch_14_val_41.remove_value_listener(self.midi_cc_ch_14_val_41_mode1_listener)
		self.midi_cc_ch_14_val_40.remove_value_listener(self.midi_cc_ch_14_val_40_mode1_listener)
		self.midi_cc_ch_14_val_28.remove_value_listener(self.midi_cc_ch_14_val_28_mode1_listener)
		self.midi_cc_ch_14_val_29.remove_value_listener(self.midi_cc_ch_14_val_29_mode1_listener)
		self.midi_cc_ch_14_val_30.remove_value_listener(self.midi_cc_ch_14_val_30_mode1_listener)
		self.midi_cc_ch_14_val_31.remove_value_listener(self.midi_cc_ch_14_val_31_mode1_listener)
		self.midi_cc_ch_14_val_32.remove_value_listener(self.midi_cc_ch_14_val_32_mode1_listener)
		self.midi_cc_ch_14_val_33.remove_value_listener(self.midi_cc_ch_14_val_33_mode1_listener)
		self.midi_cc_ch_14_val_34.remove_value_listener(self.midi_cc_ch_14_val_34_mode1_listener)
		self.midi_cc_ch_14_val_35.remove_value_listener(self.midi_cc_ch_14_val_35_mode1_listener)
		self.midi_cc_ch_14_val_36.remove_value_listener(self.midi_cc_ch_14_val_36_mode1_listener)
		self.midi_cc_ch_14_val_37.remove_value_listener(self.midi_cc_ch_14_val_37_mode1_listener)
		self.midi_cc_ch_14_val_38.remove_value_listener(self.midi_cc_ch_14_val_38_mode1_listener)
		self.midi_cc_ch_14_val_39.remove_value_listener(self.midi_cc_ch_14_val_39_mode1_listener)
		self._remove_mode1_led_listeners()
		self._remove_custom_lom_listeners_handler(1)
	def midi_cc_ch_14_val_56_mode1_listener(self, value):
		self.midi_cc_ch_14_val_56.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  tracks = self.get_num_of_tracks("tracks")
			  x = self.get_selected_track_num()
			  value = self.midi_cc_ch_14_val_56.cur_val
			
			
			  """ Calculate total of Banks """
			  a = (tracks - 1) / 8
			  banks = int(a)
			
			  if a > banks:
			    banks = banks + 1
			
			
			except AttributeError:
			  return
			
			def setBank( new ):
			  if new >= (banks * 8):
			    self.set_highlighted_track( tracks - 1)
			  elif new < 0:
			    self.set_highlighted_track(0)
			  elif new >= 0 and new <= 7:
			    self.set_highlighted_track(0)
			  elif new >= 8 and new <= 15:
			    self.set_highlighted_track(8)
			  elif new >= 16 and new <= 23:
			    self.set_highlighted_track(16)
			  elif new >= 24 and new <= 31:
			    self.set_highlighted_track(24)
			  elif new >= 32 and new <= 39:
			    self.set_highlighted_track(32)
			  elif new >= 40 and new <= 47:
			    self.set_highlighted_track(40)
			  elif new >= 48 and new <= 55:
			    self.set_highlighted_track(48)
			  elif new >= 56 and new <= 63:
			    self.set_highlighted_track(56)
			  elif new >= 64 and new <= 71:
			    self.set_highlighted_track(64)
			  elif new >= 72 and new <= 79:
			    self.set_highlighted_track(72)
			  elif new >= 80 and new <= 87:
			    self.set_highlighted_track(80)
			  elif new >= 88 and new <= 95:
			    self.set_highlighted_track(88)
			  elif new >= 96 and new <= 103:
			    self.set_highlighted_track(96)
			  elif new >= 104 and new <= 111:
			    self.set_highlighted_track(104)
			  elif new >= 112 and new <= 119:
			    self.set_highlighted_track(112)
			  elif new >= 120 and new <= 127:
			    self.set_highlighted_track(120)
			  elif new >= 128 and new <= 135:
			    self.set_highlighted_track(128)
			  elif new >= 136 and new <= 143:
			    self.set_highlighted_track(136)
			  elif new >= 144 and new <= 151:
			    self.set_highlighted_track(144)
			  elif new >= 152 and new <= 159:
			    self.set_highlighted_track(152)
			  else:
			    self.set_highlighted_track( tracks - 1 )
			  return
			
			
			""" Action """
			if tracks > 1 and str(x) != "False":
			  """ Right """
			  if value == 1 or value == 2:
			    num = x + value
			    if num >= tracks:
			      self.set_highlighted_track( x )
			    else:
			      if self.song().tracks[num].is_visible == True:
			        self.set_highlighted_track( num )
			      else:
			        num = num + 1
			        while num < tracks:
			          if self.song().tracks[num].is_visible == False:
			            num = num + 1
			          else:
			            self.set_highlighted_track( num )
			            num = tracks
			
			  if value == 3:
			    num = x + 8
			    setBank(num)
			
			  """ Left """
			  if value == 127 or value == 126:
			    num = x - (128 - value)
			    if num <= 0:
			      self.set_highlighted_track( 0 )
			    else:
			      if self.song().tracks[num].is_visible == True:
			        self.set_highlighted_track( num )
			      else:
			        num = num - 1
			        while num > 0:
			          if self.song().tracks[num].is_visible == False:
			            num = num - 1
			          else:
			            self.set_highlighted_track( num )
			            num = 0
			
			  if value == 125:
			    num = x - 8
			    setBank(num)
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Move Track' (from 'Move Track was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_56, "pre_val"):
			self.midi_cc_ch_14_val_56.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_56, "prev_press_time"):
			self.midi_cc_ch_14_val_56.prev_press_time = time.time()
		self.midi_cc_ch_14_val_56.pre_val = value
		self.midi_cc_ch_14_val_56.prev_press_time = time.time()
	def midi_cc_ch_14_val_55_mode1_listener(self, value):
		self.midi_cc_ch_14_val_55.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			def sendPitchBend( pb, val, max, min ):
			  oldRange = abs(max) + abs(min)
			  if min > 0:
			    oldRange = abs(max) - min
			  oldValue = val
			
			  if oldRange == 0:
			    newValue = 0
			  else:
			    newValue = ((oldValue - min) * 16383) / oldRange
			    if newValue >= 16383:
			      newValue = 16383
			
			    intValue = int(newValue)
			    msb = (intValue  >> 7) & 0xff
			    lsb = (intValue - (msb << 7)) & 0xff
			    self._send_midi((pb, msb, lsb))
			    return
			
			
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			
			def sendCC( status, data1, data2 ):
			  message = (status, data1, data2)
			  self._send_midi(message)
			  return
			
			
			""" Volume TrackA"""
			try:
			  trackA = self.song().view.selected_track.name
			
			  volumeA = self.song().view.selected_track.mixer_device.volume.value
			  volumeStringA = self.song().view.selected_track.mixer_device.volume.str_for_value(volumeA)
			  maxA = self.song().view.selected_track.mixer_device.volume.max
			  minA = self.song().view.selected_track.mixer_device.volume.min
			
			  sendSysex( 21, 0, trackA )
			  sendSysex( 21, 1, volumeStringA )
			  sendPitchBend( 236, volumeA, maxA, minA )
			
			except AttributeError:
			  return
			
			""" Volume TrackB"""
			try:
			  tracks = self.get_num_of_tracks("tracks")
			  x = self.get_selected_track_num()
			  b = 0
			
			  trackB = "-"
			  volumeB = 0.0
			  volumeStringB = "-"
			  maxB = 1.0
			  minB = 0.0
			
			  if tracks > 1 and str(x) != "False":
			    b = x + 1
			    if b <= (tracks - 1):
			
			      trackB = self.song().tracks[b].name
			      volumeB = self.song().tracks[b].mixer_device.volume.value
			      volumeStringB = self.song().tracks[b].mixer_device.volume.str_for_value(volumeB)
			      maxB = self.song().tracks[b].mixer_device.volume.max
			      minB = self.song().tracks[b].mixer_device.volume.min
			
			
			  sendSysex( 22, 0, trackB )
			  sendSysex( 22, 1, volumeStringB )
			  sendPitchBend( 237, volumeB, maxB, minB )
			
			
			except AttributeError:
			  return
			
			
			""" Pan """
			try:
			  pan = self.song().view.selected_track.mixer_device.panning.value
			  panString = self.song().view.selected_track.mixer_device.panning.str_for_value(pan)
			
			  sendSysex( 23, 1, panString )
			
			except AttributeError:
			  return
			
			""" Solo Mute """
			try:
			  masterName = self.song().view.selected_track.name
			  if masterName != "Master" and masterName != "Main" :
			    solo = self.song().view.selected_track.solo
			    mute = self.song().view.selected_track.mute
			
			    if solo == True:
			      sendCC( 190, 24, 127 )
			    else:
			      sendCC( 190, 24, 0 )
			
			    if mute == True:
			      sendCC( 190, 25, 127 )
			    else:
			      sendCC( 190, 25, 0 )
			
			except AttributeError:
			  return
			
			
			""" Arm Record """
			try:
			  armed = self.song().view.selected_track.can_be_armed
			  if tracks > 1 and str(x) != "False" and armed == True:
			    rec = self.song().view.selected_track.arm
			    if rec == True:
			      sendCC( 190, 26, 127 )
			    else:
			      sendCC( 190, 26, 0 )
			
			except AttributeError:
			  return
			
			
			""" Master """
			try:
			  master = self.song().master_track.mixer_device.volume.value
			  masterString = self.song().master_track.mixer_device.volume.str_for_value(master)
			
			  maxM = self.song().master_track.mixer_device.volume.max
			  minM = self.song().master_track.mixer_device.volume.min
			
			  sendSysex( 27, 1, masterString )
			
			  sendPitchBend( 238, master, maxM, minM )
			
			except AttributeError:
			  return
			
			""" Sends """
			try:
			  sendCount = self.get_modifier_value("m5")
			  i = sendCount - 1
			  total = len(self.song().view.selected_track.mixer_device.sends)
			
			  if total > 0 and sendCount <= total:
			    sendName = self.song().view.selected_track.mixer_device.sends[i].original_name
			
			    sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			    sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			
			    maxS = self.song().view.selected_track.mixer_device.sends[i].max
			    minS = self.song().view.selected_track.mixer_device.sends[i].min
			
			    sendSysex( (28 + i), 0, sendName )
			    sendSysex( (28 + i), 1, sendStrValue )
			    sendPitchBend( (224 + i), sendValue, maxS, minS )
			
			  else:
			    sendSysex( (28 + i), 0, "-" )
			    sendSysex( (28 + i), 1, "-" )
			    sendPitchBend( (224 + i), 0.0, 1.0, 0.0 )
			
			except AttributeError:
			  return
			
			
			""" Selected Parameter """
			try:
			  selected = self.song().view.selected_parameter.name
			
			  selectedA = self.song().view.selected_parameter.value
			  selectedStringA = self.song().view.selected_parameter.str_for_value(selectedA)
			  maxSelectedA = self.song().view.selected_parameter.max
			  minSelectedA = self.song().view.selected_parameter.min
			
			  self.set_modifier_value("m6", selectedA)
			
			  sendSysex( 57, 0, selected )
			  sendSysex( 57, 1, selectedStringA )
			  sendPitchBend( 239, selectedA, maxSelectedA, minSelectedA )
			
			except AttributeError:
			  return
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Callback' (from 'Callback was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_55, "pre_val"):
			self.midi_cc_ch_14_val_55.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_55, "prev_press_time"):
			self.midi_cc_ch_14_val_55.prev_press_time = time.time()
		self.midi_cc_ch_14_val_55.pre_val = value
		self.midi_cc_ch_14_val_55.prev_press_time = time.time()
	def midi_cc_ch_14_val_21_mode1_listener(self, value):
		self.midi_cc_ch_14_val_21.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			"""
			tracks = self.get_num_of_tracks("tracks")
			returns = self.get_num_of_tracks("return_tracks")
			"""
			
			def sendPitchBend( pb, val, max, min ):
			  oldRange = abs(max) + abs(min)
			  if min > 0:
			    oldRange = abs(max) - min
			  oldValue = val
			
			  if oldRange == 0:
			    newValue = 0
			  else:
			    newValue = ((oldValue - min) * 16383) / oldRange
			    if newValue >= 16383:
			      newValue = 16383
			
			    intValue = int(newValue)
			    msb = (intValue  >> 7) & 0xff
			    lsb = (intValue - (msb << 7)) & 0xff
			    self._send_midi((pb, msb, lsb))
			    return
			
			
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			try:
			  trackA = self.midi_cc_ch_14_val_21.cur_val
			  enabled = self.song().view.selected_track.mixer_device.volume.is_enabled
			  m = "m1"
			
			  max = self.song().view.selected_track.mixer_device.volume.max
			  min = self.song().view.selected_track.mixer_device.volume.min
			
			
			except AttributeError:
			  return
			
			""" Function for Default """
			def setDefault():
			  default = self.song().view.selected_track.mixer_device.volume.default_value
			  self.song().view.selected_track.mixer_device.volume.value = default
			  self.set_modifier_value(m, default)
			  
			  volumeStringA = self.song().view.selected_track.mixer_device.volume.str_for_value(default)
			  sendSysex( 21, 1, volumeStringA )
			  sendPitchBend( 236, default, max, min )
			  return
			
			""" Functions for regular parameters """
			def setParam( num ):
			  param = self.song().view.selected_track.mixer_device.volume.value + num
			
			  if param >= max:
			    self.song().view.selected_track.mixer_device.volume.value = max
			    param = max
			    self.set_modifier_value(m, max)
			  elif param <= min:
			    self.song().view.selected_track.mixer_device.volume.value = min
			    param = min
			    self.set_modifier_value(m, min)
			  else:
			    self.song().view.selected_track.mixer_device.volume.value = param
			    self.set_modifier_value(m, param)
			  
			  volumeStringA = self.song().view.selected_track.mixer_device.volume.str_for_value(param)
			  sendSysex( 21, 1, volumeStringA )
			  sendPitchBend( 236, param, max, min ) 
			
			  return
			
			def checkParam( value ):
			  if value == 1:
			    setParam( 0.003 )
			  elif value == 2:
			    setParam( 0.008 )
			  elif value == 3:
			    setParam( 0.020 )
			  elif value == 4:
			    setParam( 0.030 )
			  elif value == 5:
			    setParam( 0.040 )
			  elif value == 6:
			    setParam( 0.050 )
			  elif value == 7:
			    setParam( 0.070 )
			  elif value == 8:
			    setParam( 0.10 )
			  elif value == 127:
			    setParam( -0.003 )
			  elif value == 126:
			    setParam( -0.008 )
			  elif value == 125:
			    setParam( -0.020 )
			  elif value == 124:
			    setParam( -0.030 )
			  elif value == 123:
			    setParam( -0.040 )
			  elif value == 122:
			    setParam( -0.050 )
			  elif value == 121:
			    setParam( -0.070 )
			  elif value == 120:
			    setParam( -0.10 )
			  elif value == 0:
			    setDefault()
			  return
			
			
			""" Action """
			if enabled == True:
			  checkParam( trackA )
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Track A' (from 'TrackA was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_21, "pre_val"):
			self.midi_cc_ch_14_val_21.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_21, "prev_press_time"):
			self.midi_cc_ch_14_val_21.prev_press_time = time.time()
		self.midi_cc_ch_14_val_21.pre_val = value
		self.midi_cc_ch_14_val_21.prev_press_time = time.time()
	def midi_cc_ch_14_val_22_mode1_listener(self, value):
		self.midi_cc_ch_14_val_22.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			def sendPitchBend( pb, val, max, min ):
			  oldRange = abs(max) + abs(min)
			  if min > 0:
			    oldRange = abs(max) - min
			  oldValue = val
			
			  if oldRange == 0:
			    newValue = 0
			  else:
			    newValue = ((oldValue - min) * 16383) / oldRange
			    if newValue >= 16383:
			      newValue = 16383
			
			    intValue = int(newValue)
			    msb = (intValue  >> 7) & 0xff
			    lsb = (intValue - (msb << 7)) & 0xff
			    self._send_midi((pb, msb, lsb))
			    return
			
			
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			try:
			  trackB = self.midi_cc_ch_14_val_22.cur_val
			
			  tracks = self.get_num_of_tracks("tracks")
			  x = self.get_selected_track_num()
			  b = 0
			  enabled = False
			  m = "m2"
			
			  max = 0.0
			  min = 0.0
			
			  default = 0.0
			  param = 0.0
			
			  if tracks > 1 and str(x) != "False":
			    b = x + 1
			    if b <= (tracks - 1):
			      if self.song().tracks[b].is_visible == False:
			        c = b + 1
			        while c < tracks:
			          if self.song().tracks[c].is_visible == False:
			            c = c + 1
			          else:
			            b = c
			            c = tracks
			      if self.song().tracks[b].is_visible == True:
			        enabled = self.song().tracks[b].mixer_device.volume.is_enabled
			        max = self.song().tracks[b].mixer_device.volume.max
			        min = self.song().tracks[b].mixer_device.volume.min
			        default = self.song().tracks[b].mixer_device.volume.default_value
			        param = self.song().tracks[b].mixer_device.volume.value
			
			
			except AttributeError:
			  return
			
			
			""" Function for Default """
			def setDefault():
			  self.song().tracks[b].mixer_device.volume.value = default
			  self.set_modifier_value(m, default)
			  
			  volumeStringB = self.song().tracks[b].mixer_device.volume.str_for_value(default)
			  sendSysex( 22, 1, volumeStringB )
			  sendPitchBend( 237, default, max, min )
			
			  return
			
			
			""" Functions for regular parameters """
			def setParam( num ):
			  param = self.song().tracks[b].mixer_device.volume.value + num
			
			  if param >= max:
			    self.song().tracks[b].mixer_device.volume.value = max
			    param = max
			    self.set_modifier_value(m, max)
			  elif param <= min:
			    self.song().tracks[b].mixer_device.volume.value = min
			    param = min
			    self.set_modifier_value(m, min)
			  else:
			    self.song().tracks[b].mixer_device.volume.value = param
			    self.set_modifier_value(m, param)
			
			  volumeStringB = self.song().tracks[b].mixer_device.volume.str_for_value(param)
			  sendSysex( 22, 1, volumeStringB )
			  sendPitchBend( 237, param, max, min )
			
			  return
			
			def checkParam( value ):
			  if value == 1:
			    setParam( 0.003 )
			  elif value == 2:
			    setParam( 0.008 )
			  elif value == 3:
			    setParam( 0.020 )
			  elif value == 4:
			    setParam( 0.030 )
			  elif value == 5:
			    setParam( 0.040 )
			  elif value == 6:
			    setParam( 0.050 )
			  elif value == 7:
			    setParam( 0.070 )
			  elif value == 8:
			    setParam( 0.10 )
			  elif value == 127:
			    setParam( -0.003 )
			  elif value == 126:
			    setParam( -0.008 )
			  elif value == 125:
			    setParam( -0.020 )
			  elif value == 124:
			    setParam( -0.030 )
			  elif value == 123:
			    setParam( -0.040 )
			  elif value == 122:
			    setParam( -0.050 )
			  elif value == 121:
			    setParam( -0.070 )
			  elif value == 120:
			    setParam( -0.10 )
			  elif value == 0:
			    setDefault()
			  return
			
			""" Action """
			if enabled == True:
			  checkParam( trackB )
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Track B' (from 'TrackB was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_22, "pre_val"):
			self.midi_cc_ch_14_val_22.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_22, "prev_press_time"):
			self.midi_cc_ch_14_val_22.prev_press_time = time.time()
		self.midi_cc_ch_14_val_22.pre_val = value
		self.midi_cc_ch_14_val_22.prev_press_time = time.time()
	def midi_cc_ch_14_val_57_mode1_listener(self, value):
		self.midi_cc_ch_14_val_57.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			"""
			self.log_message("csslog: " + str(quantized) + "   " + str(self.song().view.selected_parameter.value))
			"""
			
			def sendPitchBend( pb, val, max, min ):
			  oldRange = abs(max) + abs(min)
			  if min > 0:
			    oldRange = abs(max) - min
			  oldValue = val
			
			  if oldRange == 0:
			    newValue = 0
			  else:
			    newValue = ((oldValue - min) * 16383) / oldRange
			    if newValue >= 16383:
			      newValue = 16383
			
			    intValue = int(newValue)
			    msb = (intValue  >> 7) & 0xff
			    lsb = (intValue - (msb << 7)) & 0xff
			    self._send_midi((pb, msb, lsb))
			    return
			
			
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			
			try:
			  m = "m6"
			  slider = self.midi_cc_ch_14_val_57.cur_val
			  max = self.song().view.selected_parameter.max
			  min = self.song().view.selected_parameter.min
			  range = abs(max) + abs(min)
			  if min > 0:
			    range = abs(max) - min
			  enabled = self.song().view.selected_parameter.is_enabled
			  quantized = self.song().view.selected_parameter.is_quantized
			
			
			except AttributeError:
			  return
			
			""" Function for Default """
			def setDefault():
			  default = self.song().view.selected_parameter.default_value
			  self.song().view.selected_parameter.value = default
			  valueString = self.song().view.selected_parameter.str_for_value(default)
			
			  self.set_modifier_value(m, default)
			
			  selectedStringA = self.song().view.selected_parameter.str_for_value(default)
			
			  sendSysex( 57, 1, selectedStringA )
			  sendPitchBend( 239, default, max, min )
			  return
			
			""" Functions for regular parameters """
			def setParam( num ):
			  param = self.get_modifier_value(m) + num
			
			  if param >= max:
			    self.song().view.selected_parameter.value = max
			    self.set_modifier_value(m, max)
			  elif param <= min:
			    self.song().view.selected_parameter.value = min
			    self.set_modifier_value(m, min)
			  else:
			    self.song().view.selected_parameter.value = param
			    self.set_modifier_value(m, param)
			
			  selectedA = self.song().view.selected_parameter.value
			  selectedStringA = self.song().view.selected_parameter.str_for_value(selectedA)
			
			  sendSysex( 57, 1, selectedStringA )
			  sendPitchBend( 239, selectedA, max, min )
			  return
			
			def checkParam( value ):
			  multiplier = 1
			  if range >= 0 and range <= 5:
			    multiplier = 1
			  elif range > 5 and range <= 20:
			    multiplier = 10
			  elif range > 20 and range <= 50:
			    multiplier = 40
			  elif range > 50 and range <= 70:
			    multiplier = 60
			  elif range > 70 and range < 100:
			    multiplier = 80
			
			  if value == 1:
			    setParam( 0.010 * multiplier )
			  elif value == 2:
			    setParam( 0.020 * multiplier )
			  elif value == 3:
			    setParam( 0.030 * multiplier )
			  elif value == 4:
			    setParam( 0.040 * multiplier )
			  elif value == 5:
			    setParam( 0.050 * multiplier )
			  elif value == 6:
			    setParam( 0.060 * multiplier )
			  elif value == 7:
			    setParam( 0.080 * multiplier )
			  elif value == 8:
			    setParam( 0.10 * multiplier )
			  elif value == 127:
			    setParam( -0.010 * multiplier )
			  elif value == 126:
			    setParam( -0.020 * multiplier )
			  elif value == 125:
			    setParam( -0.030 * multiplier )
			  elif value == 124:
			    setParam( -0.040 * multiplier )
			  elif value == 123:
			    setParam( -0.050 * multiplier )
			  elif value == 122:
			    setParam( -0.060 * multiplier )
			  elif value == 121:
			    setParam( -0.080 * multiplier )
			  elif value == 120:
			    setParam( -0.10 * multiplier )
			  elif value == 0:
			    setDefault()
			  return
			
			""" Functions for quantized parameters """
			def setItem( num ):
			
			  a = self.get_modifier_value(m) + num
			  if a >= max:
			    self.song().view.selected_parameter.value = max
			    self.set_modifier_value(m, max)
			  elif a <= 0:
			    self.song().view.selected_parameter.value = 0
			    self.set_modifier_value(m, 0)
			  else:
			    self.song().view.selected_parameter.value = a
			    self.set_modifier_value(m, a)
			
			  selectedA = self.song().view.selected_parameter.value
			  selectedStringA = self.song().view.selected_parameter.str_for_value(selectedA)
			
			  sendSysex( 57, 1, selectedStringA )
			  sendPitchBend( 239, selectedA, max, min )
			  return
			
			def checkItem( value ):
			  if value == 1:
			    setItem( 0.10 )
			  elif value == 2:
			    setItem( 0.20 )
			  elif value == 3:
			    setItem( 0.30 )
			  elif value == 4:
			    setItem( 0.40 )
			  elif value == 5:
			    setItem( 0.50 )
			  elif value == 6:
			    setItem( 0.60 )
			  elif value == 7:
			    setItem( 0.080 )
			  elif value == 8:
			    setItem( 1.0 )
			  elif value == 127:
			    setItem( -0.10 )
			  elif value == 126:
			    setItem( -0.20 )
			  elif value == 125:
			    setItem( -0.30 )
			  elif value == 124:
			    setItem( -0.40 )
			  elif value == 123:
			    setItem( -0.50 )
			  elif value == 122:
			    setItem( -0.60 )
			  elif value == 121:
			    setItem( -0.80 )
			  elif value == 120:
			    setItem( -1.0 )
			  return
			
			
			""" Functions for parameters with ranges larger than 100 """
			def setMacro( num ):
			  param = self.get_modifier_value(m) + num
			  if param >= max:
			    self.song().view.selected_parameter.value = max
			    self.set_modifier_value(m, max)
			  elif param <= min:
			    self.song().view.selected_parameter.value = min
			    self.set_modifier_value(m, min)
			  else:
			    self.song().view.selected_parameter.value = param
			    self.set_modifier_value(m, param)
			
			  selectedA = self.song().view.selected_parameter.value
			  selectedStringA = self.song().view.selected_parameter.str_for_value(selectedA)
			
			  sendSysex( 57, 1, selectedStringA )
			  sendPitchBend( 239, selectedA, max, min )
			  return
			
			def checkMacro( value ):
			  multiplier = 1
			  if range >= 100 and range <= 110:
			    multiplier = 0.1
			  elif range > 110 and range <= 120:
			    multiplier = 0.3
			  elif range > 120 and range <= 130:
			    multiplier = 0.6
			  elif range > 130 and range <= 150:
			    multiplier = 0.8
			  elif range > 150 and range <= 200:
			    multiplier = 1
			  elif range > 200 and range <= 300:
			    multiplier = 1.2
			  elif range > 300:
			    multiplier = 1.4
			
			  if value == 1:
			    setMacro( 1 * multiplier )
			  elif value == 2:
			    setMacro( 2 * multiplier )
			  elif value == 3:
			    setMacro( 3 * multiplier )
			  elif value == 4:
			    setMacro( 4 * multiplier )
			  elif value == 5:
			    setMacro( 5 * multiplier )
			  elif value == 6:
			    setMacro( 6 * multiplier )
			  elif value == 7:
			    setMacro( 8 * multiplier )
			  elif value == 8:
			    setMacro( 10 )
			  elif value == 127:
			    setMacro( -1 * multiplier )
			  elif value == 126:
			    setMacro( -2 * multiplier )
			  elif value == 125:
			    setMacro( -3 * multiplier )
			  elif value == 124:
			    setMacro( -4 * multiplier)
			  elif value == 123:
			    setMacro( -5 * multiplier )
			  elif value == 122:
			    setMacro( -6 * multiplier )
			  elif value == 121:
			    setMacro( -8 * multiplier )
			  elif value == 120:
			    setMacro( -10 * multiplier )
			  elif value == 0:
			    setDefault()
			  return
			
			""" Action """
			if enabled == True:
			  if quantized == True:
			    checkItem( slider )
			  else:
			    if range >= 100:
			      checkMacro( slider )
			    else:
			      checkParam( slider )
			
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Selected Parameter' (from 'Selected Parameter was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_57, "pre_val"):
			self.midi_cc_ch_14_val_57.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_57, "prev_press_time"):
			self.midi_cc_ch_14_val_57.prev_press_time = time.time()
		self.midi_cc_ch_14_val_57.pre_val = value
		self.midi_cc_ch_14_val_57.prev_press_time = time.time()
	def midi_cc_ch_14_val_23_mode1_listener(self, value):
		self.midi_cc_ch_14_val_23.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			try:
			  panning = self.midi_cc_ch_14_val_23.cur_val
			  enabled = self.song().view.selected_track.mixer_device.panning.is_enabled
			  m = "m3"
			
			  max = self.song().view.selected_track.mixer_device.panning.max
			  min = self.song().view.selected_track.mixer_device.panning.min
			
			
			except AttributeError:
			  return
			
			""" Function for Default """
			def setDefault():
			  default = self.song().view.selected_track.mixer_device.panning.default_value
			  self.song().view.selected_track.mixer_device.panning.value = default
			  self.set_modifier_value(m, default)
			
			  panString = self.song().view.selected_track.mixer_device.panning.str_for_value(default)
			  sendSysex( 23, 1, panString )
			  return
			
			""" Functions for regular parameters """
			def setParam( num ):
			  param = self.song().view.selected_track.mixer_device.panning.value + num
			
			  if param >= max:
			    self.song().view.selected_track.mixer_device.panning.value = max
			    param = max
			    self.set_modifier_value(m, max)
			  elif param <= min:
			    self.song().view.selected_track.mixer_device.panning.value = min
			    param = min
			    self.set_modifier_value(m, min)
			  else:
			    self.song().view.selected_track.mixer_device.panning.value = param
			    self.set_modifier_value(m, param)
			  
			  panString = self.song().view.selected_track.mixer_device.panning.str_for_value(param)
			  sendSysex( 23, 1, panString )
			  return
			
			def checkParam( value ):
			  if value == 1:
			    setParam( 0.010 )
			  elif value == 2:
			    setParam( 0.020 )
			  elif value == 3:
			    setParam( 0.030 )
			  elif value == 4:
			    setParam( 0.040 )
			  elif value == 5:
			    setParam( 0.050 )
			  elif value == 6:
			    setParam( 0.060 )
			  elif value == 7:
			    setParam( 0.080 )
			  elif value == 8:
			    setParam( 0.10 )
			  elif value == 127:
			    setParam( -0.010 )
			  elif value == 126:
			    setParam( -0.020 )
			  elif value == 125:
			    setParam( -0.030 )
			  elif value == 124:
			    setParam( -0.040 )
			  elif value == 123:
			    setParam( -0.050 )
			  elif value == 122:
			    setParam( -0.060 )
			  elif value == 121:
			    setParam( -0.080 )
			  elif value == 120:
			    setParam( -0.10 )
			  elif value == 0:
			    setDefault()
			  return
			
			
			""" Action """
			if enabled == True:
			  checkParam( panning )
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Panning' (from 'Panning was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_23, "pre_val"):
			self.midi_cc_ch_14_val_23.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_23, "prev_press_time"):
			self.midi_cc_ch_14_val_23.prev_press_time = time.time()
		self.midi_cc_ch_14_val_23.pre_val = value
		self.midi_cc_ch_14_val_23.prev_press_time = time.time()
	def midi_cc_ch_14_val_27_mode1_listener(self, value):
		self.midi_cc_ch_14_val_27.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			def sendPitchBend( pb, val, max, min ):
			  oldRange = abs(max) + abs(min)
			  if min > 0:
			    oldRange = abs(max) - min
			  oldValue = val
			
			  if oldRange == 0:
			    newValue = 0
			  else:
			    newValue = ((oldValue - min) * 16383) / oldRange
			    if newValue >= 16383:
			      newValue = 16383
			
			    intValue = int(newValue)
			    msb = (intValue  >> 7) & 0xff
			    lsb = (intValue - (msb << 7)) & 0xff
			    self._send_midi((pb, msb, lsb))
			    return
			
			
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			try:
			  master = self.midi_cc_ch_14_val_27.cur_val
			  enabled = self.song().master_track.mixer_device.volume.is_enabled
			  m = "m4"
			
			  max = self.song().master_track.mixer_device.volume.max
			  min = self.song().master_track.mixer_device.volume.min
			
			
			except AttributeError:
			  return
			
			""" Function for Default """
			def setDefault():
			  default = self.song().master_track.mixer_device.volume.default_value
			  self.song().master_track.mixer_device.volume.value = default
			  self.set_modifier_value(m, default)
			  
			  masterString = self.song().master_track.mixer_device.volume.str_for_value(default)
			  sendSysex( 27, 1, masterString )
			  sendPitchBend( 238, default, max, min )
			  return
			
			""" Functions for regular parameters """
			def setParam( num ):
			  param = self.song().master_track.mixer_device.volume.value + num
			
			  if param >= max:
			    self.song().master_track.mixer_device.volume.value = max
			    self.set_modifier_value(m, max)
			    param = max
			  elif param <= min:
			    self.song().master_track.mixer_device.volume.value = min
			    self.set_modifier_value(m, min)
			    param = min
			  else:
			    self.song().master_track.mixer_device.volume.value = param
			    self.set_modifier_value(m, param)
			
			  masterString = self.song().master_track.mixer_device.volume.str_for_value(param)
			  sendSysex( 27, 1, masterString )
			  sendPitchBend( 238, param, max, min )
			  return
			
			def checkParam( value ):
			  if value == 1:
			    setParam( 0.003 )
			  elif value == 2:
			    setParam( 0.008 )
			  elif value == 3:
			    setParam( 0.020 )
			  elif value == 4:
			    setParam( 0.030 )
			  elif value == 5:
			    setParam( 0.040 )
			  elif value == 6:
			    setParam( 0.050 )
			  elif value == 7:
			    setParam( 0.070 )
			  elif value == 8:
			    setParam( 0.10 )
			  elif value == 127:
			    setParam( -0.003 )
			  elif value == 126:
			    setParam( -0.008 )
			  elif value == 125:
			    setParam( -0.020 )
			  elif value == 124:
			    setParam( -0.030 )
			  elif value == 123:
			    setParam( -0.040 )
			  elif value == 122:
			    setParam( -0.050 )
			  elif value == 121:
			    setParam( -0.070 )
			  elif value == 120:
			    setParam( -0.10 )
			  elif value == 0:
			    setDefault()
			  return
			
			
			""" Action """
			if enabled == True:
			  checkParam( master )
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Master' (from 'Master was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_27, "pre_val"):
			self.midi_cc_ch_14_val_27.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_27, "prev_press_time"):
			self.midi_cc_ch_14_val_27.prev_press_time = time.time()
		self.midi_cc_ch_14_val_27.pre_val = value
		self.midi_cc_ch_14_val_27.prev_press_time = time.time()
	def midi_cc_ch_14_val_24_mode1_listener(self, value):
		self.midi_cc_ch_14_val_24.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			def sendCC( status, data1, data2 ):
			  message = (status, data1, data2)
			  self._send_midi(message)
			  return
			
			try:
			  masterName = self.song().view.selected_track.name
			  if masterName != "Master" and masterName != "Main":
			    solo = self.song().view.selected_track.solo
			
			    if solo == True:
			      self.song().view.selected_track.solo = False
			      sendCC( 191, 24, 0 )
			    else:
			      self.song().view.selected_track.solo = True
			      sendCC( 191, 24, 127 )
			
			except AttributeError:
			  return
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Solo' (from 'Solo was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_24, "pre_val"):
			self.midi_cc_ch_14_val_24.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_24, "prev_press_time"):
			self.midi_cc_ch_14_val_24.prev_press_time = time.time()
		self.midi_cc_ch_14_val_24.pre_val = value
		self.midi_cc_ch_14_val_24.prev_press_time = time.time()
	def midi_cc_ch_14_val_25_mode1_listener(self, value):
		self.midi_cc_ch_14_val_25.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			def sendCC( status, data1, data2 ):
			  message = (status, data1, data2)
			  self._send_midi(message)
			  return
			
			try:
			  masterName = self.song().view.selected_track.name
			  if masterName != "Master" and masterName != "Main":
			    mute = self.song().view.selected_track.mute
			
			    if mute == True:
			      self.song().view.selected_track.mute = False
			      sendCC( 191, 25, 0 )
			    else:
			      self.song().view.selected_track.mute = True
			      sendCC( 191, 25, 127 )
			
			except AttributeError:
			  return
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Mute' (from 'Mute was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_25, "pre_val"):
			self.midi_cc_ch_14_val_25.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_25, "prev_press_time"):
			self.midi_cc_ch_14_val_25.prev_press_time = time.time()
		self.midi_cc_ch_14_val_25.pre_val = value
		self.midi_cc_ch_14_val_25.prev_press_time = time.time()
	def midi_cc_ch_14_val_26_mode1_listener(self, value):
		self.midi_cc_ch_14_val_26.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			def sendCC( status, data1, data2 ):
			  message = (status, data1, data2)
			  self._send_midi(message)
			  return
			
			try:
			 armed = self.song().view.selected_track.can_be_armed
			 if armed == True:
			   arm = self.song().view.selected_track.arm
			
			   if arm == True:
			      self.song().view.selected_track.arm = False
			      sendCC( 191, 26, 0 )
			   else:
			      self.song().view.selected_track.arm = True
			      sendCC( 191, 26, 127 )
			
			except AttributeError:
			  return
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Arm Record' (from 'Arm Record was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_26, "pre_val"):
			self.midi_cc_ch_14_val_26.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_26, "prev_press_time"):
			self.midi_cc_ch_14_val_26.prev_press_time = time.time()
		self.midi_cc_ch_14_val_26.pre_val = value
		self.midi_cc_ch_14_val_26.prev_press_time = time.time()
	def midi_cc_ch_14_val_46_mode1_listener(self, value):
		self.midi_cc_ch_14_val_46.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  view = self.application().view.focused_document_view
			  jog = self.midi_cc_ch_14_val_46.cur_val
			
			  if view == "Session":
			    jogMov = self.get_modifier_value("m6")
			    jogMov = jogMov + 1
			    self.set_modifier_value("m6", jogMov)
			    scene = self.get_selected_scene_num()
			    total = self.get_num_of_scenes()
			    
			    if jogMov >= 2:
			      if jog <= 8:
			        scene = scene + 1
			        if scene >= (total):
			          self.set_highlighted_scene(0)
			        else:
			          self.set_highlighted_scene(scene)
			      else:
			        scene = scene - 1
			        if scene < 0:
			          self.set_highlighted_scene(total - 1)
			        else:
			          self.set_highlighted_scene(scene)
			      self.set_modifier_value("m6", 0)
			  else:
			    length = self.song().song_length
			    current = self.song().current_song_time
			    
			    scrub = self.get_modifier_value("m5")
			    if jog <= 8:
			      """
			      current = current + scrub
			      if current >= length:
			        self.song().current_song_time = length
			      else:
			        self.song().current_song_time = current
			      """
			      self.song().jump_by(scrub)
			    else:
			      """
			      current = current - scrub
			      if current <= 0.0:
			        self.song().current_song_time = 0.0
			      else:
			        self.song().current_song_time = current
			      """
			      self.song().jump_by(-(scrub))
			
			except AttributeError:
			  return
			
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Jog Wheel' (from 'Jog Wheel was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_46, "pre_val"):
			self.midi_cc_ch_14_val_46.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_46, "prev_press_time"):
			self.midi_cc_ch_14_val_46.prev_press_time = time.time()
		self.midi_cc_ch_14_val_46.pre_val = value
		self.midi_cc_ch_14_val_46.prev_press_time = time.time()
	def midi_cc_ch_14_val_42_mode1_listener(self, value):
		self.midi_cc_ch_14_val_42.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  play = self.midi_cc_ch_14_val_42.cur_val
			  playStatus = self.song().is_playing
			
			  if playStatus == False:
			    if play == 1:
			      self.song().continue_playing()
			    else:
			      self.song().start_playing()
			  else:
			    self.song().stop_playing()
			  
			except AttributeError:
			  return
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Play' (from 'Play was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_42, "pre_val"):
			self.midi_cc_ch_14_val_42.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_42, "prev_press_time"):
			self.midi_cc_ch_14_val_42.prev_press_time = time.time()
		self.midi_cc_ch_14_val_42.pre_val = value
		self.midi_cc_ch_14_val_42.prev_press_time = time.time()
	def midi_cc_ch_14_val_43_mode1_listener(self, value):
		self.midi_cc_ch_14_val_43.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  self.song().stop_playing()
			   
			except AttributeError:
			  return
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Stop' (from 'Stop was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_43, "pre_val"):
			self.midi_cc_ch_14_val_43.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_43, "prev_press_time"):
			self.midi_cc_ch_14_val_43.prev_press_time = time.time()
		self.midi_cc_ch_14_val_43.pre_val = value
		self.midi_cc_ch_14_val_43.prev_press_time = time.time()
	def midi_cc_ch_14_val_44_mode1_listener(self, value):
		self.midi_cc_ch_14_val_44.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  recordingStatus = self.song().record_mode
			  if recordingStatus == False:
			    self.song().record_mode = True
			  else:
			    self.song().record_mode = False
			   
			except AttributeError:
			  return
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Record' (from 'Global Record was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_44, "pre_val"):
			self.midi_cc_ch_14_val_44.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_44, "prev_press_time"):
			self.midi_cc_ch_14_val_44.prev_press_time = time.time()
		self.midi_cc_ch_14_val_44.pre_val = value
		self.midi_cc_ch_14_val_44.prev_press_time = time.time()
	def midi_cc_ch_14_val_54_mode1_listener(self, value):
		self.midi_cc_ch_14_val_54.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  view = self.application().view.focused_document_view
			  if view == "Session":
			    scene = self.get_selected_scene_num()
			    self.song().scenes[scene].fire_as_selected(True)
			  else:
			    value = self.get_modifier_value("m5")
			    if value == 1.0:
			      self.set_modifier_value("m5", 0.25)
			    else:
			      self.set_modifier_value("m5", 1.0)
			except AttributeError:
			  return
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Scrub' (from 'Scrub was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_54, "pre_val"):
			self.midi_cc_ch_14_val_54.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_54, "prev_press_time"):
			self.midi_cc_ch_14_val_54.prev_press_time = time.time()
		self.midi_cc_ch_14_val_54.pre_val = value
		self.midi_cc_ch_14_val_54.prev_press_time = time.time()
	def midi_cc_ch_14_val_53_mode1_listener(self, value):
		self.midi_cc_ch_14_val_53.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  q = self.song().midi_recording_quantization
			  q = q + 1
			  if q > 8:
			    self.song().midi_recording_quantization = 0
			  else:
			     self.song().midi_recording_quantization = q
			
			  status = "None"
			
			  if q == 0:
			    status = "None"
			  elif q == 1:
			    status = "1/4"
			  elif q == 2:
			    status = "1/8"
			  elif q == 3:
			    status = "1/8T"
			  elif q == 4:
			    status = "1/8 + 1/8T"
			  elif q == 5:
			    status = "1/16"
			  elif q == 6:
			    status = "1/16T"
			  elif q == 7:
			    status = "1/16 + 1/16T"
			  elif q == 8:
			    status = "1/32"
			
			  self.show_message("Record Quantization: " + status)
			
			except AttributeError:
			  return
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Record Quantization' (from 'Quantize was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_53, "pre_val"):
			self.midi_cc_ch_14_val_53.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_53, "prev_press_time"):
			self.midi_cc_ch_14_val_53.prev_press_time = time.time()
		self.midi_cc_ch_14_val_53.pre_val = value
		self.midi_cc_ch_14_val_53.prev_press_time = time.time()
	def midi_cc_ch_14_val_48_mode1_listener(self, value):
		self.midi_cc_ch_14_val_48.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  status = self.song().metronome
			  if status == False:
			    self.song().metronome = True
			  else:
			    self.song().metronome = False
			
			except AttributeError:
			  return
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Metronome' (from 'Metronome was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_48, "pre_val"):
			self.midi_cc_ch_14_val_48.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_48, "prev_press_time"):
			self.midi_cc_ch_14_val_48.prev_press_time = time.time()
		self.midi_cc_ch_14_val_48.pre_val = value
		self.midi_cc_ch_14_val_48.prev_press_time = time.time()
	def midi_cc_ch_14_val_47_mode1_listener(self, value):
		self.midi_cc_ch_14_val_47.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  status = self.song().loop
			  if status == False:
			    self.song().loop = True
			  else:
			    self.song().loop = False
			
			except AttributeError:
			  return
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Cycle' (from 'Cycle was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_47, "pre_val"):
			self.midi_cc_ch_14_val_47.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_47, "prev_press_time"):
			self.midi_cc_ch_14_val_47.prev_press_time = time.time()
		self.midi_cc_ch_14_val_47.pre_val = value
		self.midi_cc_ch_14_val_47.prev_press_time = time.time()
	def midi_cc_ch_14_val_49_mode1_listener(self, value):
		self.midi_cc_ch_14_val_49.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  status = self.song().arrangement_overdub
			  if status == False:
			    self.song().arrangement_overdub = True
			  else:
			    self.song().arrangement_overdub = False
			
			except AttributeError:
			  return
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Overdub' (from 'Overdub was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_49, "pre_val"):
			self.midi_cc_ch_14_val_49.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_49, "prev_press_time"):
			self.midi_cc_ch_14_val_49.prev_press_time = time.time()
		self.midi_cc_ch_14_val_49.pre_val = value
		self.midi_cc_ch_14_val_49.prev_press_time = time.time()
	def midi_cc_ch_14_val_50_mode1_listener(self, value):
		self.midi_cc_ch_14_val_50.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  status = self.song().session_automation_record
			  if status == False:
			    self.song().session_automation_record = True
			  else:
			    self.song().session_automation_record = False
			
			except AttributeError:
			  return
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Automation' (from 'Automation was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_50, "pre_val"):
			self.midi_cc_ch_14_val_50.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_50, "prev_press_time"):
			self.midi_cc_ch_14_val_50.prev_press_time = time.time()
		self.midi_cc_ch_14_val_50.pre_val = value
		self.midi_cc_ch_14_val_50.prev_press_time = time.time()
	def midi_cc_ch_14_val_45_mode1_listener(self, value):
		self.midi_cc_ch_14_val_45.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  status = self.song().session_record
			  if status == False:
			    self.song().session_record = True
			  else:
			    self.song().session_record = False
			
			except AttributeError:
			  return
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Session Record' (from 'Session Record was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_45, "pre_val"):
			self.midi_cc_ch_14_val_45.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_45, "prev_press_time"):
			self.midi_cc_ch_14_val_45.prev_press_time = time.time()
		self.midi_cc_ch_14_val_45.pre_val = value
		self.midi_cc_ch_14_val_45.prev_press_time = time.time()
	def midi_cc_ch_14_val_51_mode1_listener(self, value):
		self.midi_cc_ch_14_val_51.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  self.song().capture_midi(0)
			
			except AttributeError:
			  return
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Capture' (from 'Capture was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_51, "pre_val"):
			self.midi_cc_ch_14_val_51.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_51, "prev_press_time"):
			self.midi_cc_ch_14_val_51.prev_press_time = time.time()
		self.midi_cc_ch_14_val_51.pre_val = value
		self.midi_cc_ch_14_val_51.prev_press_time = time.time()
	def midi_cc_ch_14_val_52_mode1_listener(self, value):
		self.midi_cc_ch_14_val_52.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  punchIn = self.song().punch_in
			  punchOut = self.song().punch_out
			  
			  if punchIn == False and punchOut == False:
			    self.song().punch_in = True
			  if punchIn == True and punchOut == False:
			    self.song().punch_out = True
			  if punchIn == True and punchOut == True:
			    self.song().punch_in = False
			  if punchIn == False and punchOut == True:
			    self.song().punch_out = False
			
			except AttributeError:
			  return
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Punch' (from 'Punch was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_52, "pre_val"):
			self.midi_cc_ch_14_val_52.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_52, "prev_press_time"):
			self.midi_cc_ch_14_val_52.prev_press_time = time.time()
		self.midi_cc_ch_14_val_52.pre_val = value
		self.midi_cc_ch_14_val_52.prev_press_time = time.time()
	def midi_cc_ch_14_val_41_mode1_listener(self, value):
		self.midi_cc_ch_14_val_41.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			""" Sends """
			try:
			  sendCount = self.get_modifier_value("m5")
			  i = sendCount - 1
			  total = len(self.song().view.selected_track.mixer_device.sends)
			
			  if total > 0 and sendCount <= total:
			    sendState = self.song().view.selected_track.mixer_device.sends[i].state
			
			    if sendState == 0:
			      self.song().view.selected_track.mixer_device.sends[i].state = 1
			    if sendState == 1:
			      self.song().view.selected_track.mixer_device.sends[i].state = 0
			
			except AttributeError:
			  return
			
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Send On Off' (from 'Send On Off was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_41, "pre_val"):
			self.midi_cc_ch_14_val_41.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_41, "prev_press_time"):
			self.midi_cc_ch_14_val_41.prev_press_time = time.time()
		self.midi_cc_ch_14_val_41.pre_val = value
		self.midi_cc_ch_14_val_41.prev_press_time = time.time()
	def midi_cc_ch_14_val_40_mode1_listener(self, value):
		self.midi_cc_ch_14_val_40.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			def sendPitchBend( pb, val, max, min ):
			  oldRange = abs(max) + abs(min)
			  if min > 0:
			    oldRange = abs(max) - min
			  oldValue = val
			
			  if oldRange == 0:
			    newValue = 0
			  else:
			    newValue = ((oldValue - min) * 16383) / oldRange
			    if newValue >= 16383:
			      newValue = 16383
			
			    intValue = int(newValue)
			    msb = (intValue  >> 7) & 0xff
			    lsb = (intValue - (msb << 7)) & 0xff
			    self._send_midi((pb, msb, lsb))
			    return
			
			
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			
			
			""" Sends """
			try:
			  sendCount = self.midi_cc_ch_14_val_40.cur_val
			  self.set_modifier_value("m5", sendCount)
			  i = sendCount - 1
			  total = len(self.song().view.selected_track.mixer_device.sends)
			
			  if total > 0 and sendCount <= total:
			    sendName = self.song().view.selected_track.mixer_device.sends[i].original_name
			
			    sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			    sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			
			    maxS = self.song().view.selected_track.mixer_device.sends[i].max
			    minS = self.song().view.selected_track.mixer_device.sends[i].min
			
			    sendSysex( (28 + i), 0, sendName )
			    sendSysex( (28 + i), 1, sendStrValue )
			    sendPitchBend( (224 + i), sendValue, maxS, minS )
			
			  else:
			    sendSysex( (28 + i), 0, "-" )
			    sendSysex( (28 + i), 1, "-" )
			    sendPitchBend( (224 + i), 0.0, 1.0, 0.0 )
			
			except AttributeError:
			  return
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Send Count' (from 'Send Count was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_40, "pre_val"):
			self.midi_cc_ch_14_val_40.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_40, "prev_press_time"):
			self.midi_cc_ch_14_val_40.prev_press_time = time.time()
		self.midi_cc_ch_14_val_40.pre_val = value
		self.midi_cc_ch_14_val_40.prev_press_time = time.time()
	def midi_cc_ch_14_val_28_mode1_listener(self, value):
		self.midi_cc_ch_14_val_28.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  send = self.midi_cc_ch_14_val_28.cur_val
			  total = len(self.song().view.selected_track.mixer_device.sends)
			
			  enabled = False
			  max = 0.0
			  min = 0.0
			
			  m = 0.0
			
			  i = 0
			
			  if total >= (i + 1):
			    enabled = self.song().view.selected_track.mixer_device.sends[i].is_enabled
			    max = self.song().view.selected_track.mixer_device.sends[i].max
			    min = self.song().view.selected_track.mixer_device.sends[i].min
			
			except AttributeError:
			  return
			
			def sendPitchBend( pb, val, max, min ):
			  oldRange = abs(max) + abs(min)
			  if min > 0:
			    oldRange = abs(max) - min
			  oldValue = val
			
			  if oldRange == 0:
			    newValue = 0
			  else:
			    newValue = ((oldValue - min) * 16383) / oldRange
			    if newValue >= 16383:
			      newValue = 16383
			
			    intValue = int(newValue)
			    msb = (intValue  >> 7) & 0xff
			    lsb = (intValue - (msb << 7)) & 0xff
			    self._send_midi((pb, msb, lsb))
			    return
			
			
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			""" Function for Default """
			def setDefault():
			  default = self.song().view.selected_track.mixer_device.sends[i].default_value
			  self.song().view.selected_track.mixer_device.sends[i].value = default
			
			  sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			  sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			  
			  sendSysex( (28 + i), 1, sendStrValue )
			  sendPitchBend( (224 + i), sendValue, max, min )
			  
			  return
			
			""" Functions for regular parameters """
			def setParam( num ):
			  param = self.song().view.selected_track.mixer_device.sends[i].value + num
			
			  if param >= max:
			    self.song().view.selected_track.mixer_device.sends[i].value = max
			  elif param <= min:
			    self.song().view.selected_track.mixer_device.sends[i].value = min
			  else:
			    self.song().view.selected_track.mixer_device.sends[i].value = param
			
			  sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			  sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			  
			  sendSysex( (28 + i), 1, sendStrValue )
			  sendPitchBend( (224 + i), sendValue, max, min )
			  
			  return
			
			def checkParam( value ):
			  if value == 1:
			    setParam( 0.003 )
			  elif value == 2:
			    setParam( 0.008 )
			  elif value == 3:
			    setParam( 0.020 )
			  elif value == 4:
			    setParam( 0.030 )
			  elif value == 5:
			    setParam( 0.040 )
			  elif value == 6:
			    setParam( 0.050 )
			  elif value == 7:
			    setParam( 0.070 )
			  elif value == 8:
			    setParam( 0.10 )
			  elif value == 127:
			    setParam( -0.003 )
			  elif value == 126:
			    setParam( -0.008 )
			  elif value == 125:
			    setParam( -0.020 )
			  elif value == 124:
			    setParam( -0.030 )
			  elif value == 123:
			    setParam( -0.040 )
			  elif value == 122:
			    setParam( -0.050 )
			  elif value == 121:
			    setParam( -0.070 )
			  elif value == 120:
			    setParam( -0.10 )
			  elif value == 0:
			    setDefault()
			  return
			
			
			""" Action """
			if enabled == True:
			  checkParam( send )
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Send 1' (from 'Send 1 was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_28, "pre_val"):
			self.midi_cc_ch_14_val_28.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_28, "prev_press_time"):
			self.midi_cc_ch_14_val_28.prev_press_time = time.time()
		self.midi_cc_ch_14_val_28.pre_val = value
		self.midi_cc_ch_14_val_28.prev_press_time = time.time()
	def midi_cc_ch_14_val_29_mode1_listener(self, value):
		self.midi_cc_ch_14_val_29.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  send = self.midi_cc_ch_14_val_29.cur_val
			  total = len(self.song().view.selected_track.mixer_device.sends)
			
			  enabled = False
			  max = 0.0
			  min = 0.0
			
			  i = 1
			
			  if total >= (i + 1):
			    enabled = self.song().view.selected_track.mixer_device.sends[i].is_enabled
			    max = self.song().view.selected_track.mixer_device.sends[i].max
			    min = self.song().view.selected_track.mixer_device.sends[i].min
			
			except AttributeError:
			  return
			
			def sendPitchBend( pb, val, max, min ):
			  oldRange = abs(max) + abs(min)
			  if min > 0:
			    oldRange = abs(max) - min
			  oldValue = val
			
			  if oldRange == 0:
			    newValue = 0
			  else:
			    newValue = ((oldValue - min) * 16383) / oldRange
			    if newValue >= 16383:
			      newValue = 16383
			
			    intValue = int(newValue)
			    msb = (intValue  >> 7) & 0xff
			    lsb = (intValue - (msb << 7)) & 0xff
			    self._send_midi((pb, msb, lsb))
			    return
			
			
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			""" Function for Default """
			def setDefault():
			  default = self.song().view.selected_track.mixer_device.sends[i].default_value
			  self.song().view.selected_track.mixer_device.sends[i].value = default
			
			  sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			  sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			  
			  sendSysex( (28 + i), 1, sendStrValue )
			  sendPitchBend( (224 + i), sendValue, max, min )
			  
			  return
			
			""" Functions for regular parameters """
			def setParam( num ):
			  param = self.song().view.selected_track.mixer_device.sends[i].value + num
			
			  if param >= max:
			    self.song().view.selected_track.mixer_device.sends[i].value = max
			  elif param <= min:
			    self.song().view.selected_track.mixer_device.sends[i].value = min
			  else:
			    self.song().view.selected_track.mixer_device.sends[i].value = param
			
			  sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			  sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			  
			  sendSysex( (28 + i), 1, sendStrValue )
			  sendPitchBend( (224 + i), sendValue, max, min )
			  
			  return
			
			def checkParam( value ):
			  if value == 1:
			    setParam( 0.003 )
			  elif value == 2:
			    setParam( 0.008 )
			  elif value == 3:
			    setParam( 0.020 )
			  elif value == 4:
			    setParam( 0.030 )
			  elif value == 5:
			    setParam( 0.040 )
			  elif value == 6:
			    setParam( 0.050 )
			  elif value == 7:
			    setParam( 0.070 )
			  elif value == 8:
			    setParam( 0.10 )
			  elif value == 127:
			    setParam( -0.003 )
			  elif value == 126:
			    setParam( -0.008 )
			  elif value == 125:
			    setParam( -0.020 )
			  elif value == 124:
			    setParam( -0.030 )
			  elif value == 123:
			    setParam( -0.040 )
			  elif value == 122:
			    setParam( -0.050 )
			  elif value == 121:
			    setParam( -0.070 )
			  elif value == 120:
			    setParam( -0.10 )
			  elif value == 0:
			    setDefault()
			  return
			
			
			""" Action """
			if enabled == True:
			  checkParam( send )
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Send 2' (from 'Send 2 was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_29, "pre_val"):
			self.midi_cc_ch_14_val_29.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_29, "prev_press_time"):
			self.midi_cc_ch_14_val_29.prev_press_time = time.time()
		self.midi_cc_ch_14_val_29.pre_val = value
		self.midi_cc_ch_14_val_29.prev_press_time = time.time()
	def midi_cc_ch_14_val_30_mode1_listener(self, value):
		self.midi_cc_ch_14_val_30.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  send = self.midi_cc_ch_14_val_30.cur_val
			  total = len(self.song().view.selected_track.mixer_device.sends)
			
			  enabled = False
			  max = 0.0
			  min = 0.0
			
			  i = 2
			
			  if total >= (i + 1):
			    enabled = self.song().view.selected_track.mixer_device.sends[i].is_enabled
			    max = self.song().view.selected_track.mixer_device.sends[i].max
			    min = self.song().view.selected_track.mixer_device.sends[i].min
			
			except AttributeError:
			  return
			
			def sendPitchBend( pb, val, max, min ):
			  oldRange = abs(max) + abs(min)
			  if min > 0:
			    oldRange = abs(max) - min
			  oldValue = val
			
			  if oldRange == 0:
			    newValue = 0
			  else:
			    newValue = ((oldValue - min) * 16383) / oldRange
			    if newValue >= 16383:
			      newValue = 16383
			
			    intValue = int(newValue)
			    msb = (intValue  >> 7) & 0xff
			    lsb = (intValue - (msb << 7)) & 0xff
			    self._send_midi((pb, msb, lsb))
			    return
			
			
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			""" Function for Default """
			def setDefault():
			  default = self.song().view.selected_track.mixer_device.sends[i].default_value
			  self.song().view.selected_track.mixer_device.sends[i].value = default
			
			  sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			  sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			  
			  sendSysex( (28 + i), 1, sendStrValue )
			  sendPitchBend( (224 + i), sendValue, max, min )
			  
			  return
			
			""" Functions for regular parameters """
			def setParam( num ):
			  param = self.song().view.selected_track.mixer_device.sends[i].value + num
			
			  if param >= max:
			    self.song().view.selected_track.mixer_device.sends[i].value = max
			  elif param <= min:
			    self.song().view.selected_track.mixer_device.sends[i].value = min
			  else:
			    self.song().view.selected_track.mixer_device.sends[i].value = param
			
			  sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			  sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			  
			  sendSysex( (28 + i), 1, sendStrValue )
			  sendPitchBend( (224 + i), sendValue, max, min )
			  
			  return
			
			def checkParam( value ):
			  if value == 1:
			    setParam( 0.003 )
			  elif value == 2:
			    setParam( 0.008 )
			  elif value == 3:
			    setParam( 0.020 )
			  elif value == 4:
			    setParam( 0.030 )
			  elif value == 5:
			    setParam( 0.040 )
			  elif value == 6:
			    setParam( 0.050 )
			  elif value == 7:
			    setParam( 0.070 )
			  elif value == 8:
			    setParam( 0.10 )
			  elif value == 127:
			    setParam( -0.003 )
			  elif value == 126:
			    setParam( -0.008 )
			  elif value == 125:
			    setParam( -0.020 )
			  elif value == 124:
			    setParam( -0.030 )
			  elif value == 123:
			    setParam( -0.040 )
			  elif value == 122:
			    setParam( -0.050 )
			  elif value == 121:
			    setParam( -0.070 )
			  elif value == 120:
			    setParam( -0.10 )
			  elif value == 0:
			    setDefault()
			  return
			
			
			""" Action """
			if enabled == True:
			  checkParam( send )
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Send 3' (from 'Send 3 was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_30, "pre_val"):
			self.midi_cc_ch_14_val_30.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_30, "prev_press_time"):
			self.midi_cc_ch_14_val_30.prev_press_time = time.time()
		self.midi_cc_ch_14_val_30.pre_val = value
		self.midi_cc_ch_14_val_30.prev_press_time = time.time()
	def midi_cc_ch_14_val_31_mode1_listener(self, value):
		self.midi_cc_ch_14_val_31.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  send = self.midi_cc_ch_14_val_31.cur_val
			  total = len(self.song().view.selected_track.mixer_device.sends)
			
			  enabled = False
			  max = 0.0
			  min = 0.0
			
			  i = 3
			
			  if total >= (i + 1):
			    enabled = self.song().view.selected_track.mixer_device.sends[i].is_enabled
			    max = self.song().view.selected_track.mixer_device.sends[i].max
			    min = self.song().view.selected_track.mixer_device.sends[i].min
			
			except AttributeError:
			  return
			
			def sendPitchBend( pb, val, max, min ):
			  oldRange = abs(max) + abs(min)
			  if min > 0:
			    oldRange = abs(max) - min
			  oldValue = val
			
			  if oldRange == 0:
			    newValue = 0
			  else:
			    newValue = ((oldValue - min) * 16383) / oldRange
			    if newValue >= 16383:
			      newValue = 16383
			
			    intValue = int(newValue)
			    msb = (intValue  >> 7) & 0xff
			    lsb = (intValue - (msb << 7)) & 0xff
			    self._send_midi((pb, msb, lsb))
			    return
			
			
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			""" Function for Default """
			def setDefault():
			  default = self.song().view.selected_track.mixer_device.sends[i].default_value
			  self.song().view.selected_track.mixer_device.sends[i].value = default
			
			  sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			  sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			  
			  sendSysex( (28 + i), 1, sendStrValue )
			  sendPitchBend( (224 + i), sendValue, max, min )
			  
			  return
			
			""" Functions for regular parameters """
			def setParam( num ):
			  param = self.song().view.selected_track.mixer_device.sends[i].value + num
			
			  if param >= max:
			    self.song().view.selected_track.mixer_device.sends[i].value = max
			  elif param <= min:
			    self.song().view.selected_track.mixer_device.sends[i].value = min
			  else:
			    self.song().view.selected_track.mixer_device.sends[i].value = param
			
			  sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			  sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			  
			  sendSysex( (28 + i), 1, sendStrValue )
			  sendPitchBend( (224 + i), sendValue, max, min )
			  
			  return
			
			def checkParam( value ):
			  if value == 1:
			    setParam( 0.003 )
			  elif value == 2:
			    setParam( 0.008 )
			  elif value == 3:
			    setParam( 0.020 )
			  elif value == 4:
			    setParam( 0.030 )
			  elif value == 5:
			    setParam( 0.040 )
			  elif value == 6:
			    setParam( 0.050 )
			  elif value == 7:
			    setParam( 0.070 )
			  elif value == 8:
			    setParam( 0.10 )
			  elif value == 127:
			    setParam( -0.003 )
			  elif value == 126:
			    setParam( -0.008 )
			  elif value == 125:
			    setParam( -0.020 )
			  elif value == 124:
			    setParam( -0.030 )
			  elif value == 123:
			    setParam( -0.040 )
			  elif value == 122:
			    setParam( -0.050 )
			  elif value == 121:
			    setParam( -0.070 )
			  elif value == 120:
			    setParam( -0.10 )
			  elif value == 0:
			    setDefault()
			  return
			
			
			""" Action """
			if enabled == True:
			  checkParam( send )
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Send 4' (from 'Send 4 was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_31, "pre_val"):
			self.midi_cc_ch_14_val_31.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_31, "prev_press_time"):
			self.midi_cc_ch_14_val_31.prev_press_time = time.time()
		self.midi_cc_ch_14_val_31.pre_val = value
		self.midi_cc_ch_14_val_31.prev_press_time = time.time()
	def midi_cc_ch_14_val_32_mode1_listener(self, value):
		self.midi_cc_ch_14_val_32.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  send = self.midi_cc_ch_14_val_32.cur_val
			  total = len(self.song().view.selected_track.mixer_device.sends)
			
			  enabled = False
			  max = 0.0
			  min = 0.0
			
			  i = 4
			
			  if total >= (i + 1):
			    enabled = self.song().view.selected_track.mixer_device.sends[i].is_enabled
			    max = self.song().view.selected_track.mixer_device.sends[i].max
			    min = self.song().view.selected_track.mixer_device.sends[i].min
			
			except AttributeError:
			  return
			
			def sendPitchBend( pb, val, max, min ):
			  oldRange = abs(max) + abs(min)
			  if min > 0:
			    oldRange = abs(max) - min
			  oldValue = val
			
			  if oldRange == 0:
			    newValue = 0
			  else:
			    newValue = ((oldValue - min) * 16383) / oldRange
			    if newValue >= 16383:
			      newValue = 16383
			
			    intValue = int(newValue)
			    msb = (intValue  >> 7) & 0xff
			    lsb = (intValue - (msb << 7)) & 0xff
			    self._send_midi((pb, msb, lsb))
			    return
			
			
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			""" Function for Default """
			def setDefault():
			  default = self.song().view.selected_track.mixer_device.sends[i].default_value
			  self.song().view.selected_track.mixer_device.sends[i].value = default
			
			  sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			  sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			  
			  sendSysex( (28 + i), 1, sendStrValue )
			  sendPitchBend( (224 + i), sendValue, max, min )
			  
			  return
			
			""" Functions for regular parameters """
			def setParam( num ):
			  param = self.song().view.selected_track.mixer_device.sends[i].value + num
			
			  if param >= max:
			    self.song().view.selected_track.mixer_device.sends[i].value = max
			  elif param <= min:
			    self.song().view.selected_track.mixer_device.sends[i].value = min
			  else:
			    self.song().view.selected_track.mixer_device.sends[i].value = param
			
			  sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			  sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			  
			  sendSysex( (28 + i), 1, sendStrValue )
			  sendPitchBend( (224 + i), sendValue, max, min )
			  
			  return
			
			def checkParam( value ):
			  if value == 1:
			    setParam( 0.003 )
			  elif value == 2:
			    setParam( 0.008 )
			  elif value == 3:
			    setParam( 0.020 )
			  elif value == 4:
			    setParam( 0.030 )
			  elif value == 5:
			    setParam( 0.040 )
			  elif value == 6:
			    setParam( 0.050 )
			  elif value == 7:
			    setParam( 0.070 )
			  elif value == 8:
			    setParam( 0.10 )
			  elif value == 127:
			    setParam( -0.003 )
			  elif value == 126:
			    setParam( -0.008 )
			  elif value == 125:
			    setParam( -0.020 )
			  elif value == 124:
			    setParam( -0.030 )
			  elif value == 123:
			    setParam( -0.040 )
			  elif value == 122:
			    setParam( -0.050 )
			  elif value == 121:
			    setParam( -0.070 )
			  elif value == 120:
			    setParam( -0.10 )
			  elif value == 0:
			    setDefault()
			  return
			
			
			""" Action """
			if enabled == True:
			  checkParam( send )
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Send 5' (from 'Send 5 was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_32, "pre_val"):
			self.midi_cc_ch_14_val_32.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_32, "prev_press_time"):
			self.midi_cc_ch_14_val_32.prev_press_time = time.time()
		self.midi_cc_ch_14_val_32.pre_val = value
		self.midi_cc_ch_14_val_32.prev_press_time = time.time()
	def midi_cc_ch_14_val_33_mode1_listener(self, value):
		self.midi_cc_ch_14_val_33.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  send = self.midi_cc_ch_14_val_33.cur_val
			  total = len(self.song().view.selected_track.mixer_device.sends)
			
			  enabled = False
			  max = 0.0
			  min = 0.0
			
			  i = 5
			
			  if total >= (i + 1):
			    enabled = self.song().view.selected_track.mixer_device.sends[i].is_enabled
			    max = self.song().view.selected_track.mixer_device.sends[i].max
			    min = self.song().view.selected_track.mixer_device.sends[i].min
			
			except AttributeError:
			  return
			
			def sendPitchBend( pb, val, max, min ):
			  oldRange = abs(max) + abs(min)
			  if min > 0:
			    oldRange = abs(max) - min
			  oldValue = val
			
			  if oldRange == 0:
			    newValue = 0
			  else:
			    newValue = ((oldValue - min) * 16383) / oldRange
			    if newValue >= 16383:
			      newValue = 16383
			
			    intValue = int(newValue)
			    msb = (intValue  >> 7) & 0xff
			    lsb = (intValue - (msb << 7)) & 0xff
			    self._send_midi((pb, msb, lsb))
			    return
			
			
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			""" Function for Default """
			def setDefault():
			  default = self.song().view.selected_track.mixer_device.sends[i].default_value
			  self.song().view.selected_track.mixer_device.sends[i].value = default
			
			  sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			  sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			  
			  sendSysex( (28 + i), 1, sendStrValue )
			  sendPitchBend( (224 + i), sendValue, max, min )
			  
			  return
			
			""" Functions for regular parameters """
			def setParam( num ):
			  param = self.song().view.selected_track.mixer_device.sends[i].value + num
			
			  if param >= max:
			    self.song().view.selected_track.mixer_device.sends[i].value = max
			  elif param <= min:
			    self.song().view.selected_track.mixer_device.sends[i].value = min
			  else:
			    self.song().view.selected_track.mixer_device.sends[i].value = param
			
			  sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			  sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			  
			  sendSysex( (28 + i), 1, sendStrValue )
			  sendPitchBend( (224 + i), sendValue, max, min )
			  
			  return
			
			def checkParam( value ):
			  if value == 1:
			    setParam( 0.003 )
			  elif value == 2:
			    setParam( 0.008 )
			  elif value == 3:
			    setParam( 0.020 )
			  elif value == 4:
			    setParam( 0.030 )
			  elif value == 5:
			    setParam( 0.040 )
			  elif value == 6:
			    setParam( 0.050 )
			  elif value == 7:
			    setParam( 0.070 )
			  elif value == 8:
			    setParam( 0.10 )
			  elif value == 127:
			    setParam( -0.003 )
			  elif value == 126:
			    setParam( -0.008 )
			  elif value == 125:
			    setParam( -0.020 )
			  elif value == 124:
			    setParam( -0.030 )
			  elif value == 123:
			    setParam( -0.040 )
			  elif value == 122:
			    setParam( -0.050 )
			  elif value == 121:
			    setParam( -0.070 )
			  elif value == 120:
			    setParam( -0.10 )
			  elif value == 0:
			    setDefault()
			  return
			
			
			""" Action """
			if enabled == True:
			  checkParam( send )
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Send 6' (from 'Send 6 was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_33, "pre_val"):
			self.midi_cc_ch_14_val_33.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_33, "prev_press_time"):
			self.midi_cc_ch_14_val_33.prev_press_time = time.time()
		self.midi_cc_ch_14_val_33.pre_val = value
		self.midi_cc_ch_14_val_33.prev_press_time = time.time()
	def midi_cc_ch_14_val_34_mode1_listener(self, value):
		self.midi_cc_ch_14_val_34.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  send = self.midi_cc_ch_14_val_34.cur_val
			  total = len(self.song().view.selected_track.mixer_device.sends)
			
			  enabled = False
			  max = 0.0
			  min = 0.0
			
			  i = 6
			
			  if total >= (i + 1):
			    enabled = self.song().view.selected_track.mixer_device.sends[i].is_enabled
			    max = self.song().view.selected_track.mixer_device.sends[i].max
			    min = self.song().view.selected_track.mixer_device.sends[i].min
			
			except AttributeError:
			  return
			
			def sendPitchBend( pb, val, max, min ):
			  oldRange = abs(max) + abs(min)
			  if min > 0:
			    oldRange = abs(max) - min
			  oldValue = val
			
			  if oldRange == 0:
			    newValue = 0
			  else:
			    newValue = ((oldValue - min) * 16383) / oldRange
			    if newValue >= 16383:
			      newValue = 16383
			
			    intValue = int(newValue)
			    msb = (intValue  >> 7) & 0xff
			    lsb = (intValue - (msb << 7)) & 0xff
			    self._send_midi((pb, msb, lsb))
			    return
			
			
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			""" Function for Default """
			def setDefault():
			  default = self.song().view.selected_track.mixer_device.sends[i].default_value
			  self.song().view.selected_track.mixer_device.sends[i].value = default
			
			  sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			  sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			  
			  sendSysex( (28 + i), 1, sendStrValue )
			  sendPitchBend( (224 + i), sendValue, max, min )
			  
			  return
			
			""" Functions for regular parameters """
			def setParam( num ):
			  param = self.song().view.selected_track.mixer_device.sends[i].value + num
			
			  if param >= max:
			    self.song().view.selected_track.mixer_device.sends[i].value = max
			  elif param <= min:
			    self.song().view.selected_track.mixer_device.sends[i].value = min
			  else:
			    self.song().view.selected_track.mixer_device.sends[i].value = param
			
			  sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			  sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			  
			  sendSysex( (28 + i), 1, sendStrValue )
			  sendPitchBend( (224 + i), sendValue, max, min )
			  
			  return
			
			def checkParam( value ):
			  if value == 1:
			    setParam( 0.003 )
			  elif value == 2:
			    setParam( 0.008 )
			  elif value == 3:
			    setParam( 0.020 )
			  elif value == 4:
			    setParam( 0.030 )
			  elif value == 5:
			    setParam( 0.040 )
			  elif value == 6:
			    setParam( 0.050 )
			  elif value == 7:
			    setParam( 0.070 )
			  elif value == 8:
			    setParam( 0.10 )
			  elif value == 127:
			    setParam( -0.003 )
			  elif value == 126:
			    setParam( -0.008 )
			  elif value == 125:
			    setParam( -0.020 )
			  elif value == 124:
			    setParam( -0.030 )
			  elif value == 123:
			    setParam( -0.040 )
			  elif value == 122:
			    setParam( -0.050 )
			  elif value == 121:
			    setParam( -0.070 )
			  elif value == 120:
			    setParam( -0.10 )
			  elif value == 0:
			    setDefault()
			  return
			
			
			""" Action """
			if enabled == True:
			  checkParam( send )
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Send 7' (from 'Send 7 was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_34, "pre_val"):
			self.midi_cc_ch_14_val_34.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_34, "prev_press_time"):
			self.midi_cc_ch_14_val_34.prev_press_time = time.time()
		self.midi_cc_ch_14_val_34.pre_val = value
		self.midi_cc_ch_14_val_34.prev_press_time = time.time()
	def midi_cc_ch_14_val_35_mode1_listener(self, value):
		self.midi_cc_ch_14_val_35.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  send = self.midi_cc_ch_14_val_35.cur_val
			  total = len(self.song().view.selected_track.mixer_device.sends)
			
			  enabled = False
			  max = 0.0
			  min = 0.0
			
			  i = 7
			
			  if total >= (i + 1):
			    enabled = self.song().view.selected_track.mixer_device.sends[i].is_enabled
			    max = self.song().view.selected_track.mixer_device.sends[i].max
			    min = self.song().view.selected_track.mixer_device.sends[i].min
			
			except AttributeError:
			  return
			
			def sendPitchBend( pb, val, max, min ):
			  oldRange = abs(max) + abs(min)
			  if min > 0:
			    oldRange = abs(max) - min
			  oldValue = val
			
			  if oldRange == 0:
			    newValue = 0
			  else:
			    newValue = ((oldValue - min) * 16383) / oldRange
			    if newValue >= 16383:
			      newValue = 16383
			
			    intValue = int(newValue)
			    msb = (intValue  >> 7) & 0xff
			    lsb = (intValue - (msb << 7)) & 0xff
			    self._send_midi((pb, msb, lsb))
			    return
			
			
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			""" Function for Default """
			def setDefault():
			  default = self.song().view.selected_track.mixer_device.sends[i].default_value
			  self.song().view.selected_track.mixer_device.sends[i].value = default
			
			  sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			  sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			  
			  sendSysex( (28 + i), 1, sendStrValue )
			  sendPitchBend( (224 + i), sendValue, max, min )
			  
			  return
			
			""" Functions for regular parameters """
			def setParam( num ):
			  param = self.song().view.selected_track.mixer_device.sends[i].value + num
			
			  if param >= max:
			    self.song().view.selected_track.mixer_device.sends[i].value = max
			  elif param <= min:
			    self.song().view.selected_track.mixer_device.sends[i].value = min
			  else:
			    self.song().view.selected_track.mixer_device.sends[i].value = param
			
			  sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			  sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			  
			  sendSysex( (28 + i), 1, sendStrValue )
			  sendPitchBend( (224 + i), sendValue, max, min )
			  
			  return
			
			def checkParam( value ):
			  if value == 1:
			    setParam( 0.003 )
			  elif value == 2:
			    setParam( 0.008 )
			  elif value == 3:
			    setParam( 0.020 )
			  elif value == 4:
			    setParam( 0.030 )
			  elif value == 5:
			    setParam( 0.040 )
			  elif value == 6:
			    setParam( 0.050 )
			  elif value == 7:
			    setParam( 0.070 )
			  elif value == 8:
			    setParam( 0.10 )
			  elif value == 127:
			    setParam( -0.003 )
			  elif value == 126:
			    setParam( -0.008 )
			  elif value == 125:
			    setParam( -0.020 )
			  elif value == 124:
			    setParam( -0.030 )
			  elif value == 123:
			    setParam( -0.040 )
			  elif value == 122:
			    setParam( -0.050 )
			  elif value == 121:
			    setParam( -0.070 )
			  elif value == 120:
			    setParam( -0.10 )
			  elif value == 0:
			    setDefault()
			  return
			
			
			""" Action """
			if enabled == True:
			  checkParam( send )
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Send 8' (from 'Send 8 was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_35, "pre_val"):
			self.midi_cc_ch_14_val_35.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_35, "prev_press_time"):
			self.midi_cc_ch_14_val_35.prev_press_time = time.time()
		self.midi_cc_ch_14_val_35.pre_val = value
		self.midi_cc_ch_14_val_35.prev_press_time = time.time()
	def midi_cc_ch_14_val_36_mode1_listener(self, value):
		self.midi_cc_ch_14_val_36.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  send = self.midi_cc_ch_14_val_36.cur_val
			  total = len(self.song().view.selected_track.mixer_device.sends)
			
			  enabled = False
			  max = 0.0
			  min = 0.0
			
			  i = 8
			
			  if total >= (i + 1):
			    enabled = self.song().view.selected_track.mixer_device.sends[i].is_enabled
			    max = self.song().view.selected_track.mixer_device.sends[i].max
			    min = self.song().view.selected_track.mixer_device.sends[i].min
			
			except AttributeError:
			  return
			
			def sendPitchBend( pb, val, max, min ):
			  oldRange = abs(max) + abs(min)
			  if min > 0:
			    oldRange = abs(max) - min
			  oldValue = val
			
			  if oldRange == 0:
			    newValue = 0
			  else:
			    newValue = ((oldValue - min) * 16383) / oldRange
			    if newValue >= 16383:
			      newValue = 16383
			
			    intValue = int(newValue)
			    msb = (intValue  >> 7) & 0xff
			    lsb = (intValue - (msb << 7)) & 0xff
			    self._send_midi((pb, msb, lsb))
			    return
			
			
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			""" Function for Default """
			def setDefault():
			  default = self.song().view.selected_track.mixer_device.sends[i].default_value
			  self.song().view.selected_track.mixer_device.sends[i].value = default
			
			  sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			  sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			  
			  sendSysex( (28 + i), 1, sendStrValue )
			  sendPitchBend( (224 + i), sendValue, max, min )
			  
			  return
			
			""" Functions for regular parameters """
			def setParam( num ):
			  param = self.song().view.selected_track.mixer_device.sends[i].value + num
			
			  if param >= max:
			    self.song().view.selected_track.mixer_device.sends[i].value = max
			  elif param <= min:
			    self.song().view.selected_track.mixer_device.sends[i].value = min
			  else:
			    self.song().view.selected_track.mixer_device.sends[i].value = param
			
			  sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			  sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			  
			  sendSysex( (28 + i), 1, sendStrValue )
			  sendPitchBend( (224 + i), sendValue, max, min )
			  
			  return
			
			def checkParam( value ):
			  if value == 1:
			    setParam( 0.003 )
			  elif value == 2:
			    setParam( 0.008 )
			  elif value == 3:
			    setParam( 0.020 )
			  elif value == 4:
			    setParam( 0.030 )
			  elif value == 5:
			    setParam( 0.040 )
			  elif value == 6:
			    setParam( 0.050 )
			  elif value == 7:
			    setParam( 0.070 )
			  elif value == 8:
			    setParam( 0.10 )
			  elif value == 127:
			    setParam( -0.003 )
			  elif value == 126:
			    setParam( -0.008 )
			  elif value == 125:
			    setParam( -0.020 )
			  elif value == 124:
			    setParam( -0.030 )
			  elif value == 123:
			    setParam( -0.040 )
			  elif value == 122:
			    setParam( -0.050 )
			  elif value == 121:
			    setParam( -0.070 )
			  elif value == 120:
			    setParam( -0.10 )
			  elif value == 0:
			    setDefault()
			  return
			
			
			""" Action """
			if enabled == True:
			  checkParam( send )
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Send 9' (from 'Send 9 was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_36, "pre_val"):
			self.midi_cc_ch_14_val_36.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_36, "prev_press_time"):
			self.midi_cc_ch_14_val_36.prev_press_time = time.time()
		self.midi_cc_ch_14_val_36.pre_val = value
		self.midi_cc_ch_14_val_36.prev_press_time = time.time()
	def midi_cc_ch_14_val_37_mode1_listener(self, value):
		self.midi_cc_ch_14_val_37.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  send = self.midi_cc_ch_14_val_37.cur_val
			  total = len(self.song().view.selected_track.mixer_device.sends)
			
			  enabled = False
			  max = 0.0
			  min = 0.0
			
			  i = 9
			
			  if total >= (i + 1):
			    enabled = self.song().view.selected_track.mixer_device.sends[i].is_enabled
			    max = self.song().view.selected_track.mixer_device.sends[i].max
			    min = self.song().view.selected_track.mixer_device.sends[i].min
			
			except AttributeError:
			  return
			
			def sendPitchBend( pb, val, max, min ):
			  oldRange = abs(max) + abs(min)
			  if min > 0:
			    oldRange = abs(max) - min
			  oldValue = val
			
			  if oldRange == 0:
			    newValue = 0
			  else:
			    newValue = ((oldValue - min) * 16383) / oldRange
			    if newValue >= 16383:
			      newValue = 16383
			
			    intValue = int(newValue)
			    msb = (intValue  >> 7) & 0xff
			    lsb = (intValue - (msb << 7)) & 0xff
			    self._send_midi((pb, msb, lsb))
			    return
			
			
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			""" Function for Default """
			def setDefault():
			  default = self.song().view.selected_track.mixer_device.sends[i].default_value
			  self.song().view.selected_track.mixer_device.sends[i].value = default
			
			  sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			  sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			  
			  sendSysex( (28 + i), 1, sendStrValue )
			  sendPitchBend( (224 + i), sendValue, max, min )
			  
			  return
			
			""" Functions for regular parameters """
			def setParam( num ):
			  param = self.song().view.selected_track.mixer_device.sends[i].value + num
			
			  if param >= max:
			    self.song().view.selected_track.mixer_device.sends[i].value = max
			  elif param <= min:
			    self.song().view.selected_track.mixer_device.sends[i].value = min
			  else:
			    self.song().view.selected_track.mixer_device.sends[i].value = param
			
			  sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			  sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			  
			  sendSysex( (28 + i), 1, sendStrValue )
			  sendPitchBend( (224 + i), sendValue, max, min )
			  
			  return
			
			def checkParam( value ):
			  if value == 1:
			    setParam( 0.003 )
			  elif value == 2:
			    setParam( 0.008 )
			  elif value == 3:
			    setParam( 0.020 )
			  elif value == 4:
			    setParam( 0.030 )
			  elif value == 5:
			    setParam( 0.040 )
			  elif value == 6:
			    setParam( 0.050 )
			  elif value == 7:
			    setParam( 0.070 )
			  elif value == 8:
			    setParam( 0.10 )
			  elif value == 127:
			    setParam( -0.003 )
			  elif value == 126:
			    setParam( -0.008 )
			  elif value == 125:
			    setParam( -0.020 )
			  elif value == 124:
			    setParam( -0.030 )
			  elif value == 123:
			    setParam( -0.040 )
			  elif value == 122:
			    setParam( -0.050 )
			  elif value == 121:
			    setParam( -0.070 )
			  elif value == 120:
			    setParam( -0.10 )
			  elif value == 0:
			    setDefault()
			  return
			
			
			""" Action """
			if enabled == True:
			  checkParam( send )
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Send 10' (from 'Send 10 was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_37, "pre_val"):
			self.midi_cc_ch_14_val_37.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_37, "prev_press_time"):
			self.midi_cc_ch_14_val_37.prev_press_time = time.time()
		self.midi_cc_ch_14_val_37.pre_val = value
		self.midi_cc_ch_14_val_37.prev_press_time = time.time()
	def midi_cc_ch_14_val_38_mode1_listener(self, value):
		self.midi_cc_ch_14_val_38.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  send = self.midi_cc_ch_14_val_38.cur_val
			  total = len(self.song().view.selected_track.mixer_device.sends)
			
			  enabled = False
			  max = 0.0
			  min = 0.0
			
			  i = 10
			
			  if total >= (i + 1):
			    enabled = self.song().view.selected_track.mixer_device.sends[i].is_enabled
			    max = self.song().view.selected_track.mixer_device.sends[i].max
			    min = self.song().view.selected_track.mixer_device.sends[i].min
			
			except AttributeError:
			  return
			
			def sendPitchBend( pb, val, max, min ):
			  oldRange = abs(max) + abs(min)
			  if min > 0:
			    oldRange = abs(max) - min
			  oldValue = val
			
			  if oldRange == 0:
			    newValue = 0
			  else:
			    newValue = ((oldValue - min) * 16383) / oldRange
			    if newValue >= 16383:
			      newValue = 16383
			
			    intValue = int(newValue)
			    msb = (intValue  >> 7) & 0xff
			    lsb = (intValue - (msb << 7)) & 0xff
			    self._send_midi((pb, msb, lsb))
			    return
			
			
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			""" Function for Default """
			def setDefault():
			  default = self.song().view.selected_track.mixer_device.sends[i].default_value
			  self.song().view.selected_track.mixer_device.sends[i].value = default
			
			  sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			  sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			  
			  sendSysex( (28 + i), 1, sendStrValue )
			  sendPitchBend( (224 + i), sendValue, max, min )
			  
			  return
			
			""" Functions for regular parameters """
			def setParam( num ):
			  param = self.song().view.selected_track.mixer_device.sends[i].value + num
			
			  if param >= max:
			    self.song().view.selected_track.mixer_device.sends[i].value = max
			  elif param <= min:
			    self.song().view.selected_track.mixer_device.sends[i].value = min
			  else:
			    self.song().view.selected_track.mixer_device.sends[i].value = param
			
			  sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			  sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			  
			  sendSysex( (28 + i), 1, sendStrValue )
			  sendPitchBend( (224 + i), sendValue, max, min )
			  
			  return
			
			def checkParam( value ):
			  if value == 1:
			    setParam( 0.003 )
			  elif value == 2:
			    setParam( 0.008 )
			  elif value == 3:
			    setParam( 0.020 )
			  elif value == 4:
			    setParam( 0.030 )
			  elif value == 5:
			    setParam( 0.040 )
			  elif value == 6:
			    setParam( 0.050 )
			  elif value == 7:
			    setParam( 0.070 )
			  elif value == 8:
			    setParam( 0.10 )
			  elif value == 127:
			    setParam( -0.003 )
			  elif value == 126:
			    setParam( -0.008 )
			  elif value == 125:
			    setParam( -0.020 )
			  elif value == 124:
			    setParam( -0.030 )
			  elif value == 123:
			    setParam( -0.040 )
			  elif value == 122:
			    setParam( -0.050 )
			  elif value == 121:
			    setParam( -0.070 )
			  elif value == 120:
			    setParam( -0.10 )
			  elif value == 0:
			    setDefault()
			  return
			
			
			""" Action """
			if enabled == True:
			  checkParam( send )
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Send 11' (from 'Send 11 was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_38, "pre_val"):
			self.midi_cc_ch_14_val_38.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_38, "prev_press_time"):
			self.midi_cc_ch_14_val_38.prev_press_time = time.time()
		self.midi_cc_ch_14_val_38.pre_val = value
		self.midi_cc_ch_14_val_38.prev_press_time = time.time()
	def midi_cc_ch_14_val_39_mode1_listener(self, value):
		self.midi_cc_ch_14_val_39.cur_val = value 
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			try:
			  send = self.midi_cc_ch_14_val_39.cur_val
			  total = len(self.song().view.selected_track.mixer_device.sends)
			
			  enabled = False
			  max = 0.0
			  min = 0.0
			
			  i = 11
			
			  if total >= (i + 1):
			    enabled = self.song().view.selected_track.mixer_device.sends[i].is_enabled
			    max = self.song().view.selected_track.mixer_device.sends[i].max
			    min = self.song().view.selected_track.mixer_device.sends[i].min
			
			except AttributeError:
			  return
			
			def sendPitchBend( pb, val, max, min ):
			  oldRange = abs(max) + abs(min)
			  if min > 0:
			    oldRange = abs(max) - min
			  oldValue = val
			
			  if oldRange == 0:
			    newValue = 0
			  else:
			    newValue = ((oldValue - min) * 16383) / oldRange
			    if newValue >= 16383:
			      newValue = 16383
			
			    intValue = int(newValue)
			    msb = (intValue  >> 7) & 0xff
			    lsb = (intValue - (msb << 7)) & 0xff
			    self._send_midi((pb, msb, lsb))
			    return
			
			
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			""" Function for Default """
			def setDefault():
			  default = self.song().view.selected_track.mixer_device.sends[i].default_value
			  self.song().view.selected_track.mixer_device.sends[i].value = default
			
			  sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			  sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			  
			  sendSysex( (28 + i), 1, sendStrValue )
			  sendPitchBend( (224 + i), sendValue, max, min )
			  
			  return
			
			""" Functions for regular parameters """
			def setParam( num ):
			  param = self.song().view.selected_track.mixer_device.sends[i].value + num
			
			  if param >= max:
			    self.song().view.selected_track.mixer_device.sends[i].value = max
			  elif param <= min:
			    self.song().view.selected_track.mixer_device.sends[i].value = min
			  else:
			    self.song().view.selected_track.mixer_device.sends[i].value = param
			
			  sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			  sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			  
			  sendSysex( (28 + i), 1, sendStrValue )
			  sendPitchBend( (224 + i), sendValue, max, min )
			  
			  return
			
			def checkParam( value ):
			  if value == 1:
			    setParam( 0.003 )
			  elif value == 2:
			    setParam( 0.008 )
			  elif value == 3:
			    setParam( 0.020 )
			  elif value == 4:
			    setParam( 0.030 )
			  elif value == 5:
			    setParam( 0.040 )
			  elif value == 6:
			    setParam( 0.050 )
			  elif value == 7:
			    setParam( 0.070 )
			  elif value == 8:
			    setParam( 0.10 )
			  elif value == 127:
			    setParam( -0.003 )
			  elif value == 126:
			    setParam( -0.008 )
			  elif value == 125:
			    setParam( -0.020 )
			  elif value == 124:
			    setParam( -0.030 )
			  elif value == 123:
			    setParam( -0.040 )
			  elif value == 122:
			    setParam( -0.050 )
			  elif value == 121:
			    setParam( -0.070 )
			  elif value == 120:
			    setParam( -0.10 )
			  elif value == 0:
			    setDefault()
			  return
			
			
			""" Action """
			if enabled == True:
			  checkParam( send )
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Send 12' (from 'Send 12 was moved' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
		if not hasattr(self.midi_cc_ch_14_val_39, "pre_val"):
			self.midi_cc_ch_14_val_39.pre_val = None
		if not hasattr(self.midi_cc_ch_14_val_39, "prev_press_time"):
			self.midi_cc_ch_14_val_39.prev_press_time = time.time()
		self.midi_cc_ch_14_val_39.pre_val = value
		self.midi_cc_ch_14_val_39.prev_press_time = time.time()
	def _mode1_configs(self):
		self.mode_1_configs_map = []
	def _mode1_self_song_view_add_selected_track_listener_id_43(self):
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			def sendPitchBend( pb, val, max, min ):
			  oldRange = abs(max) + abs(min)
			  if min > 0:
			    oldRange = abs(max) - min
			  oldValue = val
			
			  if oldRange == 0:
			    newValue = 0
			  else:
			    newValue = ((oldValue - min) * 16383) / oldRange
			    if newValue >= 16383:
			      newValue = 16383
			
			    intValue = int(newValue)
			    msb = (intValue  >> 7) & 0xff
			    lsb = (intValue - (msb << 7)) & 0xff
			    self._send_midi((pb, msb, lsb))
			    return
			
			
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			
			def sendCC( status, data1, data2 ):
			  message = (status, data1, data2)
			  self._send_midi(message)
			  return
			
			
			""" Volume TrackA"""
			try:
			  trackA = self.song().view.selected_track.name
			
			  volumeA = self.song().view.selected_track.mixer_device.volume.value
			  volumeStringA = self.song().view.selected_track.mixer_device.volume.str_for_value(volumeA)
			  maxA = self.song().view.selected_track.mixer_device.volume.max
			  minA = self.song().view.selected_track.mixer_device.volume.min
			
			  sendSysex( 21, 0, trackA )
			  sendSysex( 21, 1, volumeStringA )
			  sendPitchBend( 236, volumeA, maxA, minA )
			
			except AttributeError:
			  return
			
			""" Volume TrackB"""
			try:
			  tracks = self.get_num_of_tracks("tracks")
			  x = self.get_selected_track_num()
			  b = 0
			
			  trackB = "-"
			  volumeB = 0.0
			  volumeStringB = "-"
			  maxB = 1.0
			  minB = 0.0
			
			  if tracks > 1 and str(x) != "False":
			    b = x + 1
			    if b <= (tracks - 1):
			
			      trackB = self.song().tracks[b].name
			      volumeB = self.song().tracks[b].mixer_device.volume.value
			      volumeStringB = self.song().tracks[b].mixer_device.volume.str_for_value(volumeB)
			      maxB = self.song().tracks[b].mixer_device.volume.max
			      minB = self.song().tracks[b].mixer_device.volume.min
			
			
			  sendSysex( 22, 0, trackB )
			  sendSysex( 22, 1, volumeStringB )
			  sendPitchBend( 237, volumeB, maxB, minB )
			
			
			except AttributeError:
			  return
			
			
			""" Pan """
			try:
			  pan = self.song().view.selected_track.mixer_device.panning.value
			  panString = self.song().view.selected_track.mixer_device.panning.str_for_value(pan)
			
			  sendSysex( 23, 1, panString )
			
			except AttributeError:
			  return
			
			""" Solo Mute """
			try:
			  masterName = self.song().view.selected_track.name
			  if masterName != "Master" and masterName != "Main" :
			    solo = self.song().view.selected_track.solo
			    mute = self.song().view.selected_track.mute
			
			    if solo == True:
			      sendCC( 190, 24, 127 )
			    else:
			      sendCC( 190, 24, 0 )
			
			    if mute == True:
			      sendCC( 190, 25, 127 )
			    else:
			      sendCC( 190, 25, 0 )
			
			except AttributeError:
			  return
			
			
			""" Arm Record """
			try:
			  armed = self.song().view.selected_track.can_be_armed
			  if tracks > 1 and str(x) != "False" and armed == True:
			    rec = self.song().view.selected_track.arm
			    if rec == True:
			      sendCC( 190, 26, 127 )
			    else:
			      sendCC( 190, 26, 0 )
			
			except AttributeError:
			  return
			
			
			""" Master """
			try:
			  master = self.song().master_track.mixer_device.volume.value
			  masterString = self.song().master_track.mixer_device.volume.str_for_value(master)
			
			  maxM = self.song().master_track.mixer_device.volume.max
			  minM = self.song().master_track.mixer_device.volume.min
			
			  sendSysex( 27, 1, masterString )
			
			  sendPitchBend( 238, master, maxM, minM )
			
			except AttributeError:
			  return
			
			""" Sends """
			try:
			  sendCount = self.get_modifier_value("m5")
			  i = sendCount - 1
			  total = len(self.song().view.selected_track.mixer_device.sends)
			
			  if total > 0 and sendCount <= total:
			    sendName = self.song().view.selected_track.mixer_device.sends[i].original_name
			
			    sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			    sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			
			    maxS = self.song().view.selected_track.mixer_device.sends[i].max
			    minS = self.song().view.selected_track.mixer_device.sends[i].min
			
			    sendSysex( (28 + i), 0, sendName )
			    sendSysex( (28 + i), 1, sendStrValue )
			    sendPitchBend( (224 + i), sendValue, maxS, minS )
			
			  else:
			    sendSysex( (28 + i), 0, "-" )
			    sendSysex( (28 + i), 1, "-" )
			    sendPitchBend( (224 + i), 0.0, 1.0, 0.0 )
			
			except AttributeError:
			  return
			
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Selected Track Changed' (from 'Song - selected track' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
	def _mode1_self_song_add_tracks_listener_id_45(self):
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			def sendPitchBend( pb, val, max, min ):
			  oldRange = abs(max) + abs(min)
			  if min > 0:
			    oldRange = abs(max) - min
			  oldValue = val
			
			  if oldRange == 0:
			    newValue = 0
			  else:
			    newValue = ((oldValue - min) * 16383) / oldRange
			    if newValue >= 16383:
			      newValue = 16383
			
			    intValue = int(newValue)
			    msb = (intValue  >> 7) & 0xff
			    lsb = (intValue - (msb << 7)) & 0xff
			    self._send_midi((pb, msb, lsb))
			    return
			
			
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			
			def sendCC( status, data1, data2 ):
			  message = (status, data1, data2)
			  self._send_midi(message)
			  return
			
			
			""" Volume TrackA"""
			try:
			  trackA = self.song().view.selected_track.name
			
			  volumeA = self.song().view.selected_track.mixer_device.volume.value
			  volumeStringA = self.song().view.selected_track.mixer_device.volume.str_for_value(volumeA)
			  maxA = self.song().view.selected_track.mixer_device.volume.max
			  minA = self.song().view.selected_track.mixer_device.volume.min
			
			  sendSysex( 21, 0, trackA )
			  sendSysex( 21, 1, volumeStringA )
			  sendPitchBend( 236, volumeA, maxA, minA )
			
			except AttributeError:
			  return
			
			""" Volume TrackB"""
			try:
			  tracks = self.get_num_of_tracks("tracks")
			  x = self.get_selected_track_num()
			  b = 0
			
			  trackB = "-"
			  volumeB = 0.0
			  volumeStringB = "-"
			  maxB = 1.0
			  minB = 0.0
			
			  if tracks > 1 and str(x) != "False":
			    b = x + 1
			    if b <= (tracks - 1):
			
			      trackB = self.song().tracks[b].name
			      volumeB = self.song().tracks[b].mixer_device.volume.value
			      volumeStringB = self.song().tracks[b].mixer_device.volume.str_for_value(volumeB)
			      maxB = self.song().tracks[b].mixer_device.volume.max
			      minB = self.song().tracks[b].mixer_device.volume.min
			
			
			  sendSysex( 22, 0, trackB )
			  sendSysex( 22, 1, volumeStringB )
			  sendPitchBend( 237, volumeB, maxB, minB )
			
			
			except AttributeError:
			  return
			
			
			""" Pan """
			try:
			  pan = self.song().view.selected_track.mixer_device.panning.value
			  panString = self.song().view.selected_track.mixer_device.panning.str_for_value(pan)
			
			  sendSysex( 23, 1, panString )
			
			except AttributeError:
			  return
			
			""" Solo Mute """
			try:
			  masterName = self.song().view.selected_track.name
			  if masterName != "Master" and masterName != "Main" :
			    solo = self.song().view.selected_track.solo
			    mute = self.song().view.selected_track.mute
			
			    if solo == True:
			      sendCC( 190, 24, 127 )
			    else:
			      sendCC( 190, 24, 0 )
			
			    if mute == True:
			      sendCC( 190, 25, 127 )
			    else:
			      sendCC( 190, 25, 0 )
			
			except AttributeError:
			  return
			
			
			""" Arm Record """
			try:
			  armed = self.song().view.selected_track.can_be_armed
			  if tracks > 1 and str(x) != "False" and armed == True:
			    rec = self.song().view.selected_track.arm
			    if rec == True:
			      sendCC( 190, 26, 127 )
			    else:
			      sendCC( 190, 26, 0 )
			
			except AttributeError:
			  return
			
			
			""" Master """
			try:
			  master = self.song().master_track.mixer_device.volume.value
			  masterString = self.song().master_track.mixer_device.volume.str_for_value(master)
			
			  maxM = self.song().master_track.mixer_device.volume.max
			  minM = self.song().master_track.mixer_device.volume.min
			
			  sendSysex( 27, 1, masterString )
			
			  sendPitchBend( 238, master, maxM, minM )
			
			except AttributeError:
			  return
			
			""" Sends """
			try:
			  sendCount = self.get_modifier_value("m5")
			  i = sendCount - 1
			  total = len(self.song().view.selected_track.mixer_device.sends)
			
			  if total > 0 and sendCount <= total:
			    sendName = self.song().view.selected_track.mixer_device.sends[i].original_name
			
			    sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			    sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			
			    maxS = self.song().view.selected_track.mixer_device.sends[i].max
			    minS = self.song().view.selected_track.mixer_device.sends[i].min
			
			    sendSysex( (28 + i), 0, sendName )
			    sendSysex( (28 + i), 1, sendStrValue )
			    sendPitchBend( (224 + i), sendValue, maxS, minS )
			
			  else:
			    sendSysex( (28 + i), 0, "-" )
			    sendSysex( (28 + i), 1, "-" )
			    sendPitchBend( (224 + i), 0.0, 1.0, 0.0 )
			
			except AttributeError:
			  return
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'New Track Added' (from 'Song - tracks' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
	def _mode1_self_song_add_return_tracks_listener_id_45(self):
		try:
			reaction_listener_number = 2
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			def sendPitchBend( pb, val, max, min ):
			  oldRange = abs(max) + abs(min)
			  if min > 0:
			    oldRange = abs(max) - min
			  oldValue = val
			
			  if oldRange == 0:
			    newValue = 0
			  else:
			    newValue = ((oldValue - min) * 16383) / oldRange
			    if newValue >= 16383:
			      newValue = 16383
			
			    intValue = int(newValue)
			    msb = (intValue  >> 7) & 0xff
			    lsb = (intValue - (msb << 7)) & 0xff
			    self._send_midi((pb, msb, lsb))
			    return
			
			
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			
			def sendCC( status, data1, data2 ):
			  message = (status, data1, data2)
			  self._send_midi(message)
			  return
			
			
			""" Volume TrackA"""
			try:
			  trackA = self.song().view.selected_track.name
			
			  volumeA = self.song().view.selected_track.mixer_device.volume.value
			  volumeStringA = self.song().view.selected_track.mixer_device.volume.str_for_value(volumeA)
			  maxA = self.song().view.selected_track.mixer_device.volume.max
			  minA = self.song().view.selected_track.mixer_device.volume.min
			
			  sendSysex( 21, 0, trackA )
			  sendSysex( 21, 1, volumeStringA )
			  sendPitchBend( 236, volumeA, maxA, minA )
			
			except AttributeError:
			  return
			
			""" Volume TrackB"""
			try:
			  tracks = self.get_num_of_tracks("tracks")
			  x = self.get_selected_track_num()
			  b = 0
			
			  trackB = "-"
			  volumeB = 0.0
			  volumeStringB = "-"
			  maxB = 1.0
			  minB = 0.0
			
			  if tracks > 1 and str(x) != "False":
			    b = x + 1
			    if b <= (tracks - 1):
			
			      trackB = self.song().tracks[b].name
			      volumeB = self.song().tracks[b].mixer_device.volume.value
			      volumeStringB = self.song().tracks[b].mixer_device.volume.str_for_value(volumeB)
			      maxB = self.song().tracks[b].mixer_device.volume.max
			      minB = self.song().tracks[b].mixer_device.volume.min
			
			
			  sendSysex( 22, 0, trackB )
			  sendSysex( 22, 1, volumeStringB )
			  sendPitchBend( 237, volumeB, maxB, minB )
			
			
			except AttributeError:
			  return
			
			
			""" Pan """
			try:
			  pan = self.song().view.selected_track.mixer_device.panning.value
			  panString = self.song().view.selected_track.mixer_device.panning.str_for_value(pan)
			
			  sendSysex( 23, 1, panString )
			
			except AttributeError:
			  return
			
			""" Solo Mute """
			try:
			  masterName = self.song().view.selected_track.name
			  if masterName != "Master" and masterName != "Main" :
			    solo = self.song().view.selected_track.solo
			    mute = self.song().view.selected_track.mute
			
			    if solo == True:
			      sendCC( 190, 24, 127 )
			    else:
			      sendCC( 190, 24, 0 )
			
			    if mute == True:
			      sendCC( 190, 25, 127 )
			    else:
			      sendCC( 190, 25, 0 )
			
			except AttributeError:
			  return
			
			
			""" Arm Record """
			try:
			  armed = self.song().view.selected_track.can_be_armed
			  if tracks > 1 and str(x) != "False" and armed == True:
			    rec = self.song().view.selected_track.arm
			    if rec == True:
			      sendCC( 190, 26, 127 )
			    else:
			      sendCC( 190, 26, 0 )
			
			except AttributeError:
			  return
			
			
			""" Master """
			try:
			  master = self.song().master_track.mixer_device.volume.value
			  masterString = self.song().master_track.mixer_device.volume.str_for_value(master)
			
			  maxM = self.song().master_track.mixer_device.volume.max
			  minM = self.song().master_track.mixer_device.volume.min
			
			  sendSysex( 27, 1, masterString )
			
			  sendPitchBend( 238, master, maxM, minM )
			
			except AttributeError:
			  return
			
			""" Sends """
			try:
			  sendCount = self.get_modifier_value("m5")
			  i = sendCount - 1
			  total = len(self.song().view.selected_track.mixer_device.sends)
			
			  if total > 0 and sendCount <= total:
			    sendName = self.song().view.selected_track.mixer_device.sends[i].original_name
			
			    sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			    sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			
			    maxS = self.song().view.selected_track.mixer_device.sends[i].max
			    minS = self.song().view.selected_track.mixer_device.sends[i].min
			
			    sendSysex( (28 + i), 0, sendName )
			    sendSysex( (28 + i), 1, sendStrValue )
			    sendPitchBend( (224 + i), sendValue, maxS, minS )
			
			  else:
			    sendSysex( (28 + i), 0, "-" )
			    sendSysex( (28 + i), 1, "-" )
			    sendPitchBend( (224 + i), 0.0, 1.0, 0.0 )
			
			except AttributeError:
			  return
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'New Track Added' (from 'Song - return tracks' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
	def _mode1_self_song_view_add_selected_parameter_listener_id_49(self):
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			def sendPitchBend( pb, val, max, min ):
			  oldRange = abs(max) + abs(min)
			  if min > 0:
			    oldRange = abs(max) - min
			  oldValue = val
			
			  if oldRange == 0:
			    newValue = 0
			  else:
			    newValue = ((oldValue - min) * 16383) / oldRange
			    if newValue >= 16383:
			      newValue = 16383
			
			    intValue = int(newValue)
			    msb = (intValue  >> 7) & 0xff
			    lsb = (intValue - (msb << 7)) & 0xff
			    self._send_midi((pb, msb, lsb))
			    return
			
			
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			
			""" Selected Parameter """
			try:
			  selected = self.song().view.selected_parameter.name
			
			  selectedA = self.song().view.selected_parameter.value
			  selectedStringA = self.song().view.selected_parameter.str_for_value(selectedA)
			  maxSelectedA = self.song().view.selected_parameter.max
			  minSelectedA = self.song().view.selected_parameter.min
			
			  self.set_modifier_value("m6", selectedA)
			
			  sendSysex( 57, 0, selected )
			  sendSysex( 57, 1, selectedStringA )
			  sendPitchBend( 239, selectedA, maxSelectedA, minSelectedA )
			
			except AttributeError:
			  return
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Selected Parameter Changed' (from 'Song - selected parameter' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
	def _mode1_self_song_view_selected_parameter_add_name_listener_id_49(self):
		try:
			reaction_listener_number = 2
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			def sendPitchBend( pb, val, max, min ):
			  oldRange = abs(max) + abs(min)
			  if min > 0:
			    oldRange = abs(max) - min
			  oldValue = val
			
			  if oldRange == 0:
			    newValue = 0
			  else:
			    newValue = ((oldValue - min) * 16383) / oldRange
			    if newValue >= 16383:
			      newValue = 16383
			
			    intValue = int(newValue)
			    msb = (intValue  >> 7) & 0xff
			    lsb = (intValue - (msb << 7)) & 0xff
			    self._send_midi((pb, msb, lsb))
			    return
			
			
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			
			""" Selected Parameter """
			try:
			  selected = self.song().view.selected_parameter.name
			
			  selectedA = self.song().view.selected_parameter.value
			  selectedStringA = self.song().view.selected_parameter.str_for_value(selectedA)
			  maxSelectedA = self.song().view.selected_parameter.max
			  minSelectedA = self.song().view.selected_parameter.min
			
			  self.set_modifier_value("m6", selectedA)
			
			  sendSysex( 57, 0, selected )
			  sendSysex( 57, 1, selectedStringA )
			  sendPitchBend( 239, selectedA, maxSelectedA, minSelectedA )
			
			except AttributeError:
			  return
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Selected Parameter Changed' (from 'Selected Parameter - name' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
	def _mode1_self_song_add_is_playing_listener_id_41(self):
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			def sendCC( status, data1, data2 ):
			  message = (status, data1, data2)
			  self._send_midi(message)
			  return
			
			try:
			  playStatus = self.song().is_playing
			
			  if playStatus == False:
			    sendCC(191, 42, 0)
			  else:
			    sendCC(191, 42, 127)
			  
			except AttributeError:
			  return
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Play is On/Off' (from 'Song - is playing' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
	def _script_was_initialised(self):
		try:
			reaction_listener_number = 1
			loop_is_active = False
			loop_number = 0
			loop_result_count = 0
			"""
			AudioSwift Mixer Script Version 1.0
			
			Uses MIDI channel 15
			
			CC21 TrackA
			CC22 TrackB
			CC23 Panning
			CC24 Solo
			CC25 Mute
			CC26 Arm Record
			CC27 Master
			CC28 to CC 39 Sends from 1 to 12
			CC40 Send Count
			CC41 Send On Off (doesn't work)
			CC42 Play
			CC43 Stop
			CC44 Global Record
			CC45 Session Record
			CC46 Jog Wheel
			CC47 Cycle
			CC48 Metronome
			CC49 Overdub
			CC50 Automation
			CC51 Capture
			CC52 Punch
			CC53 Quantize
			CC54 Rec Quantization
			CC55 Callback
			CC56 Move Track
			CC57 Selected Parameter
			
			M20 saves the ASCII table
			M19 saves the ASCII-Ext table
			M18 bool lets know if the modifier can send a sysex message to AudioSwift
			
			M1 Track A
			M2 Track B
			M3 Panning
			M4 Master
			M5 SendCount
			M6 Selected Parameter
			
			F0 00 00 66 10 xx yy F7 is the header of sysex messages
			xx = 00 is for labels
			xx = 01 is for parameters values
			yy = the corresponding CC number
			F7 is exit
			
			PB1 to PB12 Sends
			PB13 TrackA
			PB14 TrackB
			PB15 Master
			PB16 Selected Parameter
			
			
			"""
			
			""" Extended ASCII """
			ascii_ext = {138: 83, 140: 79, 142: 90, 156: 111, 158: 122, 159: 89, 192: 65, 193: 65, 194: 65, 195: 65, 196: 65, 197: 65, 198: 65, 199: 67, 200: 69, 201: 69, 202: 69, 203: 69, 204: 73, 205: 73, 206: 73, 207: 73, 208: 68, 209: 78, 210: 79, 211: 79, 212: 79, 213: 79, 214: 79, 215: 120, 216: 79, 217: 85, 218: 85, 219: 85, 220: 85, 221: 89, 223: 66, 224: 97, 225: 97, 226: 97, 227: 97, 228: 97, 229: 97, 230: 97, 231: 99, 232: 101, 233: 101, 234: 101, 235: 101, 236: 105, 237: 105, 238: 105, 239: 105, 240: 111, 241: 110, 242: 111, 243: 111, 244: 111, 245: 111, 246: 111, 247: 47, 248: 111, 249: 117, 250: 117, 251: 117, 252: 117, 253: 121, 255: 121}
			
			self.set_modifier_value("m19", ascii_ext)
			
			ascii_dict = dict()
			ascii_in_number = range(0,256)
			for i in ascii_in_number:
			    ascii_dict[chr(i)] = i
			
			self.set_modifier_value("m20", ascii_dict)
			self.set_modifier_value("m5", 1)
			
			self.show_message("AudioSwift Mixer Version: 1.0")
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			def sendPitchBend( pb, val, max, min ):
			  oldRange = abs(max) + abs(min)
			  if min > 0:
			    oldRange = abs(max) - min
			  oldValue = val
			
			  if oldRange == 0:
			    newValue = 0
			  else:
			    newValue = ((oldValue - min) * 16383) / oldRange
			    if newValue >= 16383:
			      newValue = 16383
			
			    intValue = int(newValue)
			    msb = (intValue  >> 7) & 0xff
			    lsb = (intValue - (msb << 7)) & 0xff
			    self._send_midi((pb, msb, lsb))
			    return
			
			
			
			def sendSysex( m, n, new ):
			  ascii = self.get_modifier_value("m20")
			  asciiExt = self.get_modifier_value("m19")
			
			  sysex = (240, 0, 0, 102, 16, n)
			  exit = (247,)
			  y = [m]
			
			  for i in new:
			    x = 42
			    if i in ascii:
			      x = ascii[i]
			    if x > 127:
			      if x in asciiExt:
			        x = asciiExt[x]
			      else:
			        x = 42
			    y.append(x)
			
			  if len(y) == 1:
			    y.append(45)
			
			  sysex = sysex + tuple(y) + exit
			  self._send_midi(sysex)
			  return
			
			
			def sendCC( status, data1, data2 ):
			  message = (status, data1, data2)
			  self._send_midi(message)
			  return
			
			
			""" Volume TrackA"""
			try:
			  trackA = self.song().view.selected_track.name
			
			  volumeA = self.song().view.selected_track.mixer_device.volume.value
			  volumeStringA = self.song().view.selected_track.mixer_device.volume.str_for_value(volumeA)
			  maxA = self.song().view.selected_track.mixer_device.volume.max
			  minA = self.song().view.selected_track.mixer_device.volume.min
			
			  sendSysex( 21, 0, trackA )
			  sendSysex( 21, 1, volumeStringA )
			  sendPitchBend( 236, volumeA, maxA, minA )
			
			except AttributeError:
			  return
			
			""" Volume TrackB"""
			try:
			  tracks = self.get_num_of_tracks("tracks")
			  x = self.get_selected_track_num()
			  b = 0
			
			  trackB = "-"
			  volumeB = 0.0
			  volumeStringB = "-"
			  maxB = 1.0
			  minB = 0.0
			
			  if tracks > 1 and str(x) != "False":
			    b = x + 1
			    if b <= (tracks - 1):
			
			      trackB = self.song().tracks[b].name
			      volumeB = self.song().tracks[b].mixer_device.volume.value
			      volumeStringB = self.song().tracks[b].mixer_device.volume.str_for_value(volumeB)
			      maxB = self.song().tracks[b].mixer_device.volume.max
			      minB = self.song().tracks[b].mixer_device.volume.min
			
			
			  sendSysex( 22, 0, trackB )
			  sendSysex( 22, 1, volumeStringB )
			  sendPitchBend( 237, volumeB, maxB, minB )
			
			
			except AttributeError:
			  return
			
			
			""" Pan """
			try:
			  pan = self.song().view.selected_track.mixer_device.panning.value
			  panString = self.song().view.selected_track.mixer_device.panning.str_for_value(pan)
			
			  sendSysex( 23, 1, panString )
			
			except AttributeError:
			  return
			
			""" Solo Mute """
			try:
			  masterName = self.song().view.selected_track.name
			  if masterName != "Master" and masterName != "Main" :
			    solo = self.song().view.selected_track.solo
			    mute = self.song().view.selected_track.mute
			
			    if solo == True:
			      sendCC( 190, 24, 127 )
			    else:
			      sendCC( 190, 24, 0 )
			
			    if mute == True:
			      sendCC( 190, 25, 127 )
			    else:
			      sendCC( 190, 25, 0 )
			
			except AttributeError:
			  return
			
			
			""" Arm Record """
			try:
			  armed = self.song().view.selected_track.can_be_armed
			  if tracks > 1 and str(x) != "False" and armed == True:
			    rec = self.song().view.selected_track.arm
			    if rec == True:
			      sendCC( 190, 26, 127 )
			    else:
			      sendCC( 190, 26, 0 )
			
			except AttributeError:
			  return
			
			
			""" Master """
			try:
			  master = self.song().master_track.mixer_device.volume.value
			  masterString = self.song().master_track.mixer_device.volume.str_for_value(master)
			
			  maxM = self.song().master_track.mixer_device.volume.max
			  minM = self.song().master_track.mixer_device.volume.min
			
			  sendSysex( 27, 1, masterString )
			
			  sendPitchBend( 238, master, maxM, minM )
			
			except AttributeError:
			  return
			
			""" Sends """
			try:
			  sendCount = self.get_modifier_value("m5")
			  i = sendCount - 1
			  total = len(self.song().view.selected_track.mixer_device.sends)
			
			  if total > 0 and sendCount <= total:
			    sendName = self.song().view.selected_track.mixer_device.sends[i].original_name
			
			    sendValue = self.song().view.selected_track.mixer_device.sends[i].value
			    sendStrValue = self.song().view.selected_track.mixer_device.sends[i].str_for_value(sendValue)
			
			    maxS = self.song().view.selected_track.mixer_device.sends[i].max
			    minS = self.song().view.selected_track.mixer_device.sends[i].min
			
			    sendSysex( (28 + i), 0, sendName )
			    sendSysex( (28 + i), 1, sendStrValue )
			    sendPitchBend( (224 + i), sendValue, maxS, minS )
			
			  else:
			    sendSysex( (28 + i), 0, "-" )
			    sendSysex( (28 + i), 1, "-" )
			    sendPitchBend( (224 + i), 0.0, 1.0, 0.0 )
			
			except AttributeError:
			  return
			
		except Exception as e:
			self.log_message("csslog:(AudioSwift Mixer) There's a problem with 'Action Block 1' in reaction 'Script Initialization' (from 'script is initialised' listener) >> ")
			self.log_message("csslog: >> " + str(e) )
	def _mode1_led_listeners(self):
		try:
			self._mode1_fire_all_feedback()
		except:
			self.log("_mode1_led_listeners tried to call _mode1_fire_all_feedback but it does not exist")
		try:
			self.song().add_tracks_listener(self._all_tracks_listener)
		except:
			self.log("_mode1_led_listeners tried to call add_tracks_listener but it does not exist")
		try:
			self.all_track_device_listeners()
		except:
			self.log("_mode1_led_listeners tried to call all_track_device_listeners but it does not exist")
		try:
			self._mode1_ui_listeners()
		except:
			self.log("_mode1_led_listeners tried to call _mode1_ui_listeners but it does not exist")
		self.track_feedback(1)
		self.device_feedback(1)
		self.mode_device_bank_leds(1)
	def _remove_mode1_led_listeners(self):
		try:
			self.song().remove_tracks_listener(self._all_tracks_listener)
		except:
			self.log("_remove_mode1_led_listeners tried to call remove_tracks_listener but it does not exist")
		try:
			self._remove_all_track_device_listeners()
		except:
			self.log("_remove_mode1_led_listeners tried to call _remove_all_track_device_listeners but it does not exist")
		try:
			self._remove_mode1_ui_listeners()
		except:
			self.log("_remove_mode1_led_listeners tried to call _remove_mode1_ui_listeners but it does not exist")	
	################## CORE: Python 3 #################
	def get_value_from_ranges(self, a1, b2, c3, d4, e5, f6, g7, h8, i9, j10, k11):
		logging = a1 
		steps = b2 
		round_down = c3 
		current_input_value = d4 
		i = {}
		i["minimum"] = e5 
		i["maximum"] = f6 
		i["decimal_places"] = g7 
		i["steps"] = steps
		i["distance"] = i["maximum"] - i["minimum"] 
		i["speed"] = i["distance"] / i["steps"] 
		inn = self.step_values(i) 
		o = {}
		o["minimum"] = h8 
		o["maximum"] = i9 
		o["decimal_places"] = j10 
		o["reverse_mode"] = k11 
		o["steps"] = steps
		o["distance"] = o["maximum"] - o["minimum"] 
		o["speed"] = o["distance"] / o["steps"] 
		out = self.step_values(o) 
		closest_inn = self.f_n(inn, current_input_value, round_down)
		relative_out_value = out[closest_inn['index']]
		ret = {}
		ret['in'] = inn
		ret['selected_in'] = closest_inn
		ret['out'] = out
		ret["selected_out"] = relative_out_value
		if(logging == True): 
			if(round_down == False):
				rounding = "up"
				rou_symb = str(">")
			else:
				rounding = "down"
				rou_symb = str("<")
			log_arr = []
			log_arr.append("In: " + str(current_input_value) )
			log_arr.append("Out: " + str(ret["selected_out"]) )
			log_arr.append("Steps: " + str(steps) )
			log_arr.append("Rounding: " + str(rounding) )
			log_arr.append("Rev: " + str(o["reverse_mode"]) )
			log_str = ' '.join(log_arr)
			table_arr = []
			table_arr.append(str("<table class='rangeValueTable'>") )
			step_arr = []
			count = 0
			for item in ret['in']:
				if(count==ret['selected_in']['index']):
					td = "<td class='slctd'>"
				else:
					td = "<td>"
				step_arr.append(td + str(count) + "</td>")
				count = count + 1
			step_str = ''.join(step_arr)
			in_arr = []
			count = 0
			for item in ret['in']:
				td = "<td>"
				if(count==ret['selected_in']['index']):
					td = "<td class='slctd'>"
				in_arr.append(td + str(item) + "</td>")
				count = count + 1
			in_str = ''.join(in_arr)
					
			out_arr = []
			count = 0
			for item in ret['out']:
				td = "<td>"
				if(count==ret['selected_in']['index']):
					td = "<td class='slctd'>"
				out_arr.append(td + str(item) + "</td>")
				count = count + 1
			out_str = ''.join(out_arr)
			rev = ""
			if o["reverse_mode"] == True:
				rev = "(Rev)"
			
			table_arr.append(str("<tr><td class='hd'>Steps</td>" + step_str + "</tr>") )
			table_arr.append(str("<tr><td class='hd'>In (" + rou_symb + str(current_input_value) + ")</td>" + in_str + "</tr>") )
			table_arr.append(str("<tr><td class='hd'>Out " + rev + "</td>" + out_str + "</tr>") )
			table_arr.append(str("</table>") )
			table_str = ''.join(table_arr)
			self.log_message("csslog: " + str(table_str) )
		return ret["selected_out"]
			
	def f_n(self, array, current_val, round_down = True):     
		i = 0
		nearest = {}
		nearest['index'] = None
		nearest['value'] = None
		prev_idx = i 
		prev_val = array[0] 
		for array_val in array:
			if array_val == current_val:
				nearest['index'] = i
				nearest['value'] = array_val
				break
			elif current_val > prev_val and current_val < array_val:
				if round_down is True:
					nearest['index'] = prev_idx
					nearest['value'] = prev_val
				else:
					nearest['index'] = i
					nearest['value'] = array_val
				break
			else: 
				prev_val = array_val
				prev_idx = i
				i = i + 1
		return nearest;
	def placehold_listener(self, value):
		return
	def pick_brain(self, obj):
		cnfg = obj.copy() 
		if cnfg["output_type"] == "val":
				self.val_brain(cnfg)
		elif cnfg["output_type"] == "func":
			self.func_brain(cnfg)
		elif cnfg["output_type"] == "bool":
			self.bool_brain(cnfg)
	def should_it_fire(self, cnfg):
		controller = getattr(self, cnfg["attached_to"])
		cnfg["value"] = controller.cur_val 
		cnfg["pre_val"] = controller.pre_val 
		cnfg["prev_press_time"] = controller.prev_press_time
		timenow = time.time()
		fire = 0;
		if (cnfg["ctrl_type"] == "on/off" or cnfg["ctrl_type"] == "increment" or cnfg["ctrl_type"] == "decrement"): 
			if(cnfg["switch_type"] == "delay"):
				if((cnfg["value"] == cnfg["enc_second"]) and (timenow - cnfg["prev_press_time"]) > cnfg["delay_amount"]):
					fire = 1;
			elif(cnfg["switch_type"] == "toggle"):
				if cnfg["value"] == cnfg["enc_first"] or cnfg["value"] == cnfg["enc_second"]:
					fire = 1;
			elif (cnfg["switch_type"] == "momentary" and cnfg["value"] == cnfg["enc_first"]):
				fire = 1;
		elif cnfg["ctrl_type"] == "absolute":
			if cnfg["value"] >= cnfg["enc_first"] and cnfg["value"] <= cnfg["enc_second"]:
				fire = 1;
		elif cnfg["ctrl_type"] == "relative":
			if cnfg["value"] == cnfg["enc_first"] or cnfg["value"] == cnfg["enc_second"]:
				fire = 1;
		return fire
	def bool_brain(self, cnfg):
		method_to_call = getattr(eval(cnfg["module"]), cnfg["element"])
		fire = self.should_it_fire(cnfg)
		if fire == 1:
			if cnfg["element"] == "solo" and self.song().exclusive_solo:
				for index in range(len(self.song().tracks)):
					self.song().tracks[index].solo = False
				for index in range(len(self.song().return_tracks)):
					self.song().return_tracks[index].solo = False
			if cnfg["element"] == "arm" and self.song().exclusive_arm:
				for index in range(len(self.song().tracks)):
					try:
						self.song().tracks[index].arm = False
					except Exception as e:
						continue           
			if method_to_call is False:
				try:
					setattr(eval(cnfg["module"]), cnfg["element"], True)
				except Exception as e:
					self.show_message("Unable to set " + str(cnfg["element"]) + " to True")
			else: 
				try:
					setattr(eval(cnfg["module"]), cnfg["element"], False)
				except Exception as e:
					self.show_message("Unable to set " + str(cnfg["element"]) + " to False")
	def func_brain(self, cnfg):
		fire = self.should_it_fire(cnfg)
		if fire == 1: 
			method_to_call = getattr(eval(cnfg["module"]), cnfg["element"])
			if cnfg["func_arg"] != "" and cnfg["func_arg"] != "cnfg":
				method_to_call(cnfg["func_arg"]) 
			elif cnfg["func_arg"] == "cnfg":
				method_to_call(cnfg) 
			else: 
				method_to_call()
	def val_brain(self, cnfg):
		try:
			cnfg["current_position"] = getattr(eval(cnfg["module"]), cnfg["element"]) 
		except:
			self.show_message("This control does not exist in your session")
			return
		self._parameter_to_map_to = eval(cnfg["module"])
		if cnfg["ctrl_type"] != "on/off" and hasattr(self._parameter_to_map_to, "max") and hasattr(self._parameter_to_map_to, "min"):
			param_range = self._parameter_to_map_to.max - self._parameter_to_map_to.min
			if "minimum" in cnfg:
				usermin = cnfg["minimum"] / 100.;
				min_value = float(usermin * param_range) 
				cnfg["minimum"] = min_value + self._parameter_to_map_to.min
			if "maximum" in cnfg and cnfg["mapping_type"] != "On/Off":
				usermax = cnfg["maximum"] / 100.;
				max_value = float(usermax * param_range) 
				cnfg["maximum"] = max_value + self._parameter_to_map_to.min
		controller = getattr(self, cnfg["attached_to"])
		cnfg["value"] = controller.cur_val 
		cnfg["pre_val"] = controller.pre_val 
		if "decimal_places" in cnfg:
			cnfg["current_position"] = round(cnfg["current_position"], cnfg["decimal_places"])
		if cnfg["ctrl_type"] == "absolute":
			cnfg["steps"] = (cnfg["enc_second"] - cnfg["enc_first"]) 
		if cnfg["ctrl_type"] != "on/off":
			cnfg["distance"] = cnfg["maximum"] - cnfg["minimum"] 
			cnfg["speed"] = cnfg["distance"] / cnfg["steps"] 
			cnfg["step_values"] = self.step_values(cnfg) 
			cnfg["velocity_seq"] = self._velocity_seq(cnfg) 
		
		if int(cnfg["current_position"]) < int(cnfg["minimum"]) or int(cnfg["current_position"]) > int(cnfg["maximum"]):
			new_val = self.snap_to_max_min(cnfg)
		elif cnfg["ctrl_type"] == "absolute":
			new_val = self.absolute_decision(cnfg)
		elif cnfg["ctrl_type"] == "relative":
			new_val = self.relative_decision(cnfg)
		elif cnfg["ctrl_type"] == "on/off" or cnfg["ctrl_type"] == "increment" or cnfg["ctrl_type"] == "decrement":
			new_val = self.button_decision(cnfg)
		try:
			setattr(eval(cnfg["module"]), cnfg["element"], new_val)
		except:
			return
	def snap_to_max_min(self, cnfg):
		
		if(cnfg["enc_first"] < cnfg["enc_second"]):
			enc_lowest = cnfg["enc_first"];
			enc_highest = cnfg["enc_second"]
		else:
			enc_lowest = cnfg["enc_second"];
			enc_highest = cnfg["enc_first"]
		if cnfg["snap_to"] == True and (cnfg["value"] <= enc_lowest or cnfg["value"] >= enc_highest):
			if int(cnfg["current_position"]) < int(cnfg["minimum"]):
				new_val = cnfg["minimum"]
				self.log("snapped to min")
			elif int(cnfg["current_position"]) > int(cnfg["maximum"]):
				new_val = cnfg["maximum"]
				self.log("snapped to max")
		else:
			new_val = cnfg["current_position"]
			self.show_message("remotify: snapping is off for this control. Check min / max values")
		return new_val
	def step_values(self, cnfg):
		calc = []
		for i in range(0, cnfg["steps"] +1):
			val = (i * cnfg["speed"]) + cnfg["minimum"]
			if "decimal_places" in cnfg:
				val = round(val, cnfg["decimal_places"])
				if cnfg["decimal_places"] is 0:
					val = int(val) 
			calc.append(val)
		if "reverse_mode" in cnfg and cnfg["reverse_mode"] is True:
			calc = list(reversed(calc))
		return calc
	def relative_decision(self, cnfg):
		fire = 0
		new_val = cnfg["current_position"] 
		if cnfg["value"] == cnfg["enc_second"]: 
			max_min = "max" 
			fire = 1
		elif cnfg["value"] == cnfg["enc_first"]: 
			max_min = "min" 
			fire = 1
		if fire == 0:
			return new_val
		if cnfg["current_position"] in cnfg["step_values"]:
			current_pos_index = cnfg["step_values"].index(cnfg["current_position"])
			
			feedback = current_pos_index / cnfg["steps"] * 127
			feedback = round(feedback, 0)
			method_to_call = getattr(self, cnfg["attached_to"])
			incr_index = current_pos_index + 1
			decr_index = current_pos_index - 1
			if max_min == "max" and incr_index < len(cnfg["step_values"]): 
				incr = cnfg["step_values"][incr_index]
				while incr == cnfg["current_position"]:
					incr_index = incr_index + 1
					if incr_index < len(cnfg["step_values"]):
						incr = cnfg["step_values"][incr_index]
					else:
						break
				new_val = incr
			elif max_min == "min" and decr_index >= 0: 
				decr = cnfg["step_values"][decr_index]
				new_val = decr
			return new_val    
		else:   
			new_val = self.step_in_line(cnfg, max_min)
			return new_val
		return new_val
	def percent_as_value(self, param, percentage):
		param = 		eval(param)
		if hasattr(param, 'max') and hasattr(param, 'min'):
			param_range = param.max - param.min
			val = percentage * param_range / 100
			return val
		else: 
			self.log("param does not have min and/or max attribute(s)")
	def button_decision(self, cnfg):
		new_val = cnfg["current_position"] 
		fire = self.should_it_fire(cnfg)
		if fire == 0:
			return new_val;
		if cnfg["ctrl_type"] == "on/off":
			if(cnfg["switch_type"] == "toggle"):
				if cnfg["value"] == cnfg["enc_first"]:
					new_val = cnfg["maximum"]
					return new_val
				elif cnfg["value"] == cnfg["enc_second"]:
					new_val = cnfg["minimum"]
					return new_val
			elif(cnfg["switch_type"] == "momentary"):
				if(cnfg["current_position"] == cnfg["maximum"]):
					new_val = cnfg["minimum"]
				else: 
					new_val = cnfg["maximum"]
				return new_val
			elif(cnfg["switch_type"] == "delay"):
				if(cnfg["current_position"] == cnfg["maximum"]):
					new_val = cnfg["minimum"]
				elif (cnfg["current_position"] == cnfg["minimum"]):
					new_val = cnfg["maximum"]
				return new_val
			else:
				self.log("neither momentary or toggle were set for on off button")
				return new_val
		if cnfg["current_position"] in cnfg["step_values"]:
			current_pos_index = cnfg["step_values"].index(cnfg["current_position"])
			incr_index = current_pos_index + 1
			decr_index = current_pos_index - 1
			if cnfg["ctrl_type"] ==  "increment" and incr_index < len(cnfg["step_values"]): 
				incr = cnfg["step_values"][incr_index]
				new_val = incr
			elif cnfg["ctrl_type"] == "decrement" and decr_index >= 0: 
				decr = cnfg["step_values"][decr_index]
				new_val = decr
			return new_val
		else:
			if cnfg["ctrl_type"] ==  "increment": 
				max_min = "max"
			elif cnfg["ctrl_type"] == "decrement": max_min = "min"
			new_val = self.step_in_line(cnfg, max_min)
			return new_val
		return new_val
	def step_in_line(self, cnfg, max_min):
		previous = int()
		step_num = 0
		speed = 0 
		for step_val in cnfg["step_values"]:
			step_num += 1
			if cnfg["current_position"] > previous and cnfg["current_position"] < step_val:
				if max_min == "min":
					speed = cnfg["current_position"] - previous 
					new_val = previous
				elif max_min == "max":
					speed = step_val - cnfg["current_position"] 
					new_val = step_val
				break
			previous = step_val
		return new_val
	def absolute_decision(self, cnfg):
		if(cnfg["enc_first"] > cnfg["enc_second"]):
			self.log("enc_first is higher than enc_second, needs to be lower")
		new_val = cnfg["current_position"] 
		if cnfg["pre_val"] is None:
			return new_val
		######### Get pre_val details from list values ######### 
		######### ######### ######### ######## ######
		if cnfg["pre_val"] in cnfg["velocity_seq"]: 
			cnfg["previous_step_num"] = cnfg["velocity_seq"].index(cnfg["pre_val"]) 
			cnfg["previous_step_value"] = cnfg["step_values"][cnfg["previous_step_num"]] 
		else:
			cnfg["previous_step_value"] = None
		######### get value details from list ######### 
		######### ######### ######### ######### ######
		if cnfg["value"] in cnfg["velocity_seq"]:
			cnfg["step_num"] = cnfg["velocity_seq"].index(cnfg["value"]) 
			cnfg["step_value"] = cnfg["step_values"][cnfg["step_num"]] 
		else: 
			cnfg["step_num"] = None
			cnfg["step_value"] = None
			
		######### MAX OR MIN ########
		######### ######### ######### 
		if cnfg["reverse_mode"] is False:
			if cnfg["value"] > cnfg["pre_val"]: max_min = "max"
			elif cnfg["value"] < cnfg["pre_val"]: max_min = "min"
		elif cnfg["reverse_mode"] is True:
			if cnfg["value"] > cnfg["pre_val"]: max_min = "min"
			elif cnfg["value"] < cnfg["pre_val"]: max_min = "max"
		inside_outside = self.inside_outside_checks(cnfg)
		if inside_outside is not False:
			self.log("inside outside was not false")
			return inside_outside
		######### straight assign or takeover ######### 
		######### ######### ######### ######### #######
		if cnfg["previous_step_value"] == cnfg["current_position"]:
			new_val = cnfg["step_value"]
		elif cnfg["takeover_mode"] == "None": 
			new_val = cnfg["step_value"]
		elif cnfg["takeover_mode"] == "Pickup": 
			new_val = self.pickup(cnfg, max_min)
		elif cnfg["takeover_mode"] == "Value scaling": new_val = self.value_scaling(cnfg, max_min)
		else: self.log("nothing got decided")
			
		return new_val
	def inside_outside_checks(self, cnfg):
		new_val = cnfg["current_position"]
		if cnfg["reverse_mode"] is False: 
			minimum = cnfg["minimum"]
			maximum = cnfg["maximum"]
		elif cnfg["reverse_mode"] is True: 
			minimum = cnfg["maximum"]
			maximum = cnfg["minimum"]
		######### was outside and is still outside ######
		######### ######### ######### ######### ######### 
		if (cnfg["pre_val"] < cnfg["enc_first"] and cnfg["value"] < cnfg["enc_first"]):
			self.log("was below and still below")
			return new_val
		elif (cnfg["pre_val"] > cnfg["enc_second"] and cnfg["value"] > cnfg["enc_second"]):
			self.log("was above and still above")
			return new_val
		## 1. Going Below
		if (cnfg["pre_val"] >= cnfg["enc_first"] and cnfg["value"] < cnfg["enc_first"]): 
			self.log("going below enter")
			if cnfg["takeover_mode"] == "Pickup":
				if cnfg["reverse_mode"] is False and cnfg["current_position"] > cnfg["previous_step_value"]:
					return new_val
				elif cnfg["reverse_mode"] is True and cnfg["current_position"] < cnfg["previous_step_value"]:
					return new_val
			if cnfg["reverse_mode"] is False:
				new_val = minimum
				self.log("going below 1")
				return new_val
			elif cnfg["reverse_mode"] is True:
				new_val = minimum
				self.log("going below 2")
				return new_val
		## 2. Going Above
		if (cnfg["pre_val"] <= cnfg["enc_second"] and cnfg["value"] > cnfg["enc_second"]):
			if cnfg["takeover_mode"] == "Pickup":
				self.log("THIS SHOULD FIRE 1")
				if cnfg["reverse_mode"] is False and cnfg["current_position"] < cnfg["previous_step_value"]:
					self.log("THIS SHOULD FIRE 2")
					return new_val
				elif cnfg["reverse_mode"] is True and cnfg["current_position"] > cnfg["previous_step_value"]:
					return new_val 
			if cnfg["reverse_mode"] is False:
				new_val = maximum
				self.log("going above 1")
				return new_val
			elif cnfg["reverse_mode"] is True:
				new_val = maximum
				self.log("going above 2")
				return new_val
		#########  >>0<< Coming inside ########
		######### ######### ######### ######### 
		if (cnfg["pre_val"] < cnfg["enc_first"] and cnfg["value"] >= cnfg["enc_first"]):
			self.log("come in from below")
			
		elif (cnfg["pre_val"] > cnfg["enc_second"] and cnfg["value"] <= cnfg["enc_second"]):
			self.log("coming in from above")
		return False
	def _velocity_seq(self,cnfg):
		number_of_steps = cnfg['enc_second'] - cnfg['enc_first']
		arr = []
		i = 0
		sequence_num = cnfg['enc_first']
		while i <= number_of_steps:
			arr.append(sequence_num)
			i += 1
			sequence_num += 1
		return arr
	def pickup(self, cnfg, max_min):
		new_val = cnfg["current_position"] 
		found = False
		if cnfg["previous_step_value"] is None:
			self.log("just entered")
			
			if cnfg["reverse_mode"] is False:
				if cnfg["pre_val"] < cnfg["enc_first"] and cnfg["step_value"] > cnfg["current_position"]:
					new_val = cnfg["step_value"]
					found = True
					self.log("pickup 1 found")
				elif cnfg["pre_val"] > cnfg["enc_second"] and cnfg["step_value"] < cnfg["current_position"]:
					new_val = cnfg["step_value"]
					found = True
					self.log("pickup 2 found")
			elif cnfg["reverse_mode"] is True:
				if cnfg["pre_val"] < cnfg["enc_first"] and cnfg["step_value"] < cnfg["current_position"]:
					new_val = cnfg["step_value"]
					found = True
					self.log("pickup 3 found")
				elif cnfg["pre_val"] > cnfg["enc_second"] and cnfg["step_value"] > cnfg["current_position"]:
					new_val = cnfg["step_value"]
					found = True
					self.log("pickup 4 found")
		
		else:
			self.log("we were already in here")
			
			if cnfg["previous_step_value"] < cnfg["current_position"] and cnfg["step_value"] > cnfg["current_position"]: 
				new_val = cnfg["step_value"]
				found = True
				self.log("pickup 4 found")
			elif cnfg["previous_step_value"] > cnfg["current_position"] and cnfg["step_value"] < cnfg["current_position"] :
				new_val = cnfg["step_value"]
				found = True  
				self.log("pickup 5 found")
			else: 
				self.log("waiting for pickup")
		if found is False:
			msg = "remotify says: waiting for pickup " + str(cnfg["step_value"]) + " >> " + str(cnfg["current_position"])
			self.show_message(msg)
		return new_val
		step_num = cnfg["step_num"]
		step_value = cnfg["step_value"]
		remaining_steps = cnfg["steps"] - step_num 
		new_val = cnfg["current_position"] 
		distance_to_max = cnfg["maximum"] - cnfg["current_position"]
		distance_to_min = cnfg["current_position"] - cnfg["minimum"]
		speed_to_max = 0
		speed_to_min = 0
		if cnfg["current_position"] >= cnfg["minimum"] and cnfg["current_position"] <= cnfg["maximum"]:
			if max_min == "max" and distance_to_max > 0:
				if cnfg["reverse_mode"] is False and remaining_steps > 0: speed_to_max = distance_to_max / remaining_steps
				elif cnfg["reverse_mode"] is True and step_num > 0: speed_to_max = distance_to_max / step_num
				if speed_to_max is not 0: new_val = speed_to_max + cnfg["current_position"]
			elif max_min == "min" and distance_to_min > 0:
				if cnfg["reverse_mode"] is False and step_num > 0: speed_to_min = distance_to_min / step_num
				elif cnfg["reverse_mode"] is True and remaining_steps > 0: speed_to_min = distance_to_min / remaining_steps
				if speed_to_min is not 0: new_val = cnfg["current_position"] - speed_to_min
		return new_val
	def value_scaling(self, cnfg, max_min):
		step_num = cnfg["step_num"]
		step_value = cnfg["step_value"]
		remaining_steps = cnfg["steps"] - step_num 
		new_val = cnfg["current_position"] 
		distance_to_max = cnfg["maximum"] - cnfg["current_position"]
		distance_to_min = cnfg["current_position"] - cnfg["minimum"]
		speed_to_max = 0
		speed_to_min = 0
		if cnfg["current_position"] >= cnfg["minimum"] and cnfg["current_position"] <= cnfg["maximum"]:
			if max_min == "max" and distance_to_max > 0:
				if cnfg["reverse_mode"] is False and remaining_steps > 0: speed_to_max = distance_to_max / remaining_steps
				elif cnfg["reverse_mode"] is True and step_num > 0: speed_to_max = distance_to_max / step_num
				if speed_to_max is not 0: new_val = speed_to_max + cnfg["current_position"]
			elif max_min == "min" and distance_to_min > 0:
				if cnfg["reverse_mode"] is False and step_num > 0: speed_to_min = distance_to_min / step_num
				elif cnfg["reverse_mode"] is True and remaining_steps > 0: speed_to_min = distance_to_min / remaining_steps
				if speed_to_min is not 0: new_val = cnfg["current_position"] - speed_to_min
		return new_val
	def track_num_2(self, track_num):
		if ((hasattr(self, '_session')) and (self._session is not None)):
			track_num = track_num + self._session._track_offset
			
		else: 
			track_num = track_num
		return track_num
	def track_num(self, track_num):
		if ((hasattr(self, '_session')) and (self._session is not None)):
			track_num = track_num + self._session._track_offset
		else: 
			track_num = track_num
		return track_num
	def scene_num(self, scene_num):
		if ((hasattr(self, '_session')) and (self._session is not None)):
			scene_num = scene_num + self._session._scene_offset 
		else: 
			scene_num = scene_num
		return scene_num
	def log_cnfg_settings(self, cnfg):
		for i in cnfg:
			text = i + ": " + str(cnfg[i])
			self.log(text)
	def dump(self, obj):
		for attr in dir(obj):
			self.log("csslog: obj.%s = %r" % (attr, getattr(obj, attr)))
	def log(self, msg):
		if self.debug_on is True:
			self.log_message("csslog:" + str(msg))
	def pret(self, ugly):
		for key,value in sorted(ugly.items()):
			self.log_message(key)
			self.log_message(value)
			self.log_message("")
	################## Extra Functions: Python 3 #################
	def get_list(self, list_name):
		try:
			if list_name in self.lists:
				return self.lists[list_name]["value"]
			else: 
				self.log_message('csslog: The custom list "' + str(list_name) + '" does not exist')
				return False
		except Exception as e:
			self.log_message('csslog: There was an error getting a custom list with "get_list", ' + str(e))
			return False
	def get_list_length(self, list_name):
		theList = self.get_list(list_name) 
		if theList is False: 
			return False
		return len(theList)
	def get_list_item(self, list_name, item_num):
		try:
			theList = self.get_list(list_name) 
			if theList is False: 
				return False
			
			list_len = self.get_list_length(list_name)
			if list_len is False: 
				return
			if list_len >= item_num:
				return theList[item_num - 1]
			else: 
				self.log_message('csslog: Custom list "' + str(list_name) + '" does not have ' + str(item_num) + ' items')
				return False
		except Exception as e:
			self.log_message('csslog: There was an error in "get_list_item"', str(e))
			return False
	def add_to_list(self, list_name, value_to_add, position):
		try:
			theList = self.get_list(list_name)
			if theList is False: 
				return False
			list_len = self.get_list_length(list_name)
			if position is None or position > list_len: 
				position = list_len 
			theList.insert(position, value_to_add) 
		except Exception as e: 
			self.log_message('csslog: There was an error in "add_to_list()", ' + str(e))
			return False; 
	def remove_from_list(self, list_name, position):
		try:
			theList = self.get_list(list_name)
			if theList is False: 
				return False
			list_len = self.get_list_length(list_name)
			if list_len == 0:
				self.log_message("csslog: Nothing to delete from list '" + str(list_name) + "' as it's already empty")
				return
			if position > list_len:
				self.log_message("csslog: Custom list '" + str(list_name) + "' does not contain " + str(position) + " items")
				return False
			if position is None: 
				position = list_len
			theList.pop(position)
		except Exception as e: 
			self.log_message('csslog: There was an error in "remove_from_list", ' + str(e))
			return False; 
	def clear_list(self, list_name):
		try:
			theList = self.get_list(list_name)
			if theList is False: 
				return False
			del theList[:] 
		except Exception as e: 
			self.log_message('csslog: There was an error in "clear_list", ' + str(e))
			return False; 
	def get_num_of_tracks(self, track_slug):
		try:
			s = "self.song()." + track_slug
			s = eval(s)
			return len(s)
		except: 
			self.log_message('There was an error in get_num_of_tracks()')
			return -1
	
	def get_num_of_scenes(self):
		try:
			s = "self.song().scenes"
			s = eval(s)
			return len(s)
		except: 
			self.log_message('There was an error in get_num_of_scenes()')
			return -1
	
	def get_num_of_devices(self, track_slug):
		try:
			s = "self.song()." + track_slug + ".devices"
			s = eval(s)
			return len(s)
		except: 
			self.log_message('There was an error in get_num_of_devices()')
			return -1
	
	def get_selected_track_num(self):
		track = self.song().view.selected_track
		track = self.tuple_index(self.song().tracks, track)
		return track
	
	def get_selected_scene_num(self):
		scene = self.song().view.selected_scene
		scene = self.tuple_index(self.song().scenes, scene)
		return scene
	
	def get_selected_device_num(self, track_slug):
		try:
			device_list = "self.song()." + track_slug + ".devices" 
			selected_device = "self.song()." + track_slug + ".view.selected_device" 
			s = self.tuple_index(eval(device_list), eval(selected_device))
			if(s == False and s != 0):
				s = -1
			return s
		except:
			self.log_message('csslog: There was an error in get_num_of_devices()')
			return -1
	def get_active_mode_id(self):
		global active_mode
		return active_mode
	def get_sessbox_track_offset(self):
		if hasattr(self, '_session') and self._session is not None:
			return self._session._track_offset
		else:
			return -1
	def get_sessbox_scene_offset(self):
		if hasattr(self, '_session') and self._session is not None:
			return self._session._scene_offset
		else:
			return -1
	def get_sessbox_last_track_number(self):
		if hasattr(self, '_session') and self._session is not None:
			last_track = self._session._track_offset + self._session.width()
			return last_track
		else:
			return -1
	def get_sessbox_last_scene_number(self):
		if hasattr(self, '_session') and self._session is not None:
			last_scene = self._session._scene_offset + self._session.height()
			return last_scene
		else:
			return -1
	def get_sessbox_width(self):
		if hasattr(self, '_session') and self._session is not None:
			return self._session.width()
		else:
			return -1
	def get_sessbox_height(self):
		if hasattr(self, '_session') and self._session is not None:
			return self._session.height()
		else:
			return -1
		
	def get_sessbox_is_active(self):
		if hasattr(self, '_session') and self._session is not None:
			return True
		else:
			return False
	def set_highlighted_track(self, n):
		self.song().view.selected_track = self.song().tracks[n]
	
	def set_highlighted_scene(self, n):
		self.song().view.selected_scene = self.song().scenes[n]
	def set_sessionbox_offsets(self, track_offset, scene_offset):
		if hasattr(self, '_session') and self._session is not None:
			self._session.set_offsets(track_offset, scene_offset)
			self._set_session_highlight( self._session.track_offset(), self._session.scene_offset(), self._session.width(), self._session.height(), True)
			self.call_script_reaction(active_mode, None, 'session_box_position')
	def set_sessionbox_combo_mode(self, combo):
		if hasattr(self, '_session') and self._session is not None:
			if combo == True:
				self._session._link
			elif combo == False:
				self._session._unlink
	def _quantizeDict(self):
		grid_setting = str(self.song().view.highlighted_clip_slot.clip.view.grid_quantization)
		is_it_triplet = self.song().view.highlighted_clip_slot.clip.view.grid_is_triplet
		if (is_it_triplet is True):
			grid_setting += "_triplet"
		RecordingQuantization = Live.Song.RecordingQuantization
		quantDict = {}
		quantDict["g_thirtysecond"] = RecordingQuantization.rec_q_thirtysecond
		quantDict["g_sixteenth"] = RecordingQuantization.rec_q_sixtenth
		quantDict["g_eighth"] = RecordingQuantization.rec_q_eight
		quantDict["g_quarter"] = RecordingQuantization.rec_q_quarter
		quantDict["g_eighth_triplet"] = RecordingQuantization.rec_q_eight_triplet
		quantDict["g_sixteenth_triplet"] = RecordingQuantization.rec_q_sixtenth_triplet
		return quantDict[grid_setting];
	def _arm_follow_track_selection(self):
		for track in self.song().tracks:
			if track.can_be_armed:
				track.arm = False
		if self.song().view.selected_track.can_be_armed:
			self.song().view.selected_track.arm = True
	def turn_inputs_off(self): 
		send_feedback = False
		if hasattr(self, "global_feedback"): 
			if self.global_feedback == "custom":
				if self.global_feedback_active == True: 
					send_feedback = True
			elif hasattr(self, "controller_LED_on") and hasattr(self, "controller_LED_off"):
				send_feedback = True
		if send_feedback == True: 
			for input_name in self.input_map:
				input_ctrl = getattr(self, input_name)
				input_ctrl.send_value(self.led_off)
	def feedback_brain(self, obj):
		cnfg = obj.copy() 
		try:
			method_to_call = getattr(self, cnfg["feedback_brain"])
			method_to_call(cnfg)
		except:
			return 
	def feedback_bool(self, feedback_to):
		control =   eval("self." + str(feedback_to["attached_to"]))
		param =     eval(feedback_to["module"] + "." + feedback_to["ui_listener"])
		ctrl_on =   self.feedback_which_ctrl_on_off(feedback_to, "on")
		ctrl_off =  self.feedback_which_ctrl_on_off(feedback_to, "off")
		if(feedback_to["mapping_type"] == "Mute"):
			if param == False:
				send_val = ctrl_on
			elif param == True:
				send_val = ctrl_off
		else: 
			if param == True:
				send_val = ctrl_on
			elif param == False:
				send_val = ctrl_off
		self.feedback_handler(feedback_to, send_val)
	def feedback_on_off(self, feedback_to):
		param =     eval(feedback_to["module"])
		ctrl_on =   self.feedback_which_ctrl_on_off(feedback_to, "on")
		ctrl_off =  self.feedback_which_ctrl_on_off(feedback_to, "off")
		param_value = round(param.value,2) 
		mapping_type = str(feedback_to["mapping_type"])
		if "maximum" in feedback_to and "minimum" in feedback_to:
			max_val = feedback_to["maximum"]
			min_val = feedback_to["minimum"]
		elif hasattr(param, "max") and hasattr(param, "min"): 
			max_val = param.max
			max_val = round(max_val,2)
			min_val = param.min
			min_val = round(min_val,2)
		else: 
			self.log_message(str(param) + " does not have a max/min param")
			return
		send_val = None
		if param_value == max_val:
			send_val = ctrl_on
		elif param_value == min_val:
			send_val = ctrl_off
		if send_val is not None:
			self.feedback_handler(feedback_to, send_val)
		else: 
			return
	def feedback_increment(self, feedback_to):
		control =   eval("self." + str(feedback_to["attached_to"]))
		param =     eval(feedback_to["module"])
		mapping_type = str(feedback_to["mapping_type"])
		ctrl_on =   self.feedback_which_ctrl_on_off(feedback_to, "on")
		ctrl_off =  self.feedback_which_ctrl_on_off(feedback_to, "off")
		snapping = feedback_to["snap_to"]
		mapping_type = str(feedback_to["mapping_type"])
		if "maximum" in feedback_to and "minimum" in feedback_to:
			max_val = feedback_to["maximum"]
			min_val = feedback_to["minimum"]
			if mapping_type != "On/Off":
				max_val = self.percent_as_value(feedback_to["module"], feedback_to["maximum"])
				min_val = self.percent_as_value(feedback_to["module"], feedback_to["minimum"])
		elif hasattr(param, "max") and hasattr(param, "min"): 
			max_val = param.max
			min_val = param.min
		else: 
			self.log_message(str(param) + " does not have a max/min param")
			return
		if snapping == False and param.value < min_val:
			send_val = ctrl_off
		elif param.value < max_val: 
			send_val = ctrl_on
		else: 
			send_val = ctrl_off
		self.feedback_handler(feedback_to, send_val)
	def feedback_decrement(self, feedback_to):
		control =   eval("self." + str(feedback_to["attached_to"]))
		param =     eval(feedback_to["module"])
		mapping_type = str(feedback_to["mapping_type"])
		ctrl_on =   self.feedback_which_ctrl_on_off(feedback_to, "on")
		ctrl_off =  self.feedback_which_ctrl_on_off(feedback_to, "off")
		snapping = feedback_to["snap_to"]
		if "maximum" in feedback_to and "minimum" in feedback_to:
			max_val = feedback_to["maximum"]
			min_val = feedback_to["minimum"]
			if mapping_type != "On/Off":
				max_val = self.percent_as_value(feedback_to["module"], feedback_to["maximum"])
				min_val = self.percent_as_value(feedback_to["module"], feedback_to["minimum"])
		elif hasattr(param, "max") and hasattr(param, "min"): 
			max_val = param.max
			min_val = param.min
		else: 
			self.log_message(str(param) + " does not have a max/min param")
			return
		if snapping == False and param.value > max_val:
			send_val = ctrl_off
		elif param.value > min_val: 
			send_val = ctrl_on
		else: 
			send_val = ctrl_off
		self.feedback_handler(feedback_to, send_val)
	def feedback_which_ctrl_on_off(self, feedback_to, on_off):
		if feedback_to["LED_feedback"] == "default":
			ctrl_on = self.led_on
			ctrl_off = self.led_off
		elif feedback_to["LED_feedback"] == "custom":
			if feedback_to["ctrl_type"] == "on/off" or feedback_to["ctrl_type"] == "increment" or feedback_to["ctrl_type"] == "decrement":
				ctrl_on = feedback_to["LED_on"]
				ctrl_off = feedback_to["LED_off"]
			elif feedback_to["ctrl_type"] == "absolute" or feedback_to["ctrl_type"] == "relative":
				ctrl_on = feedback_to["enc_first"]
				ctrl_off = feedback_to["enc_second"]
		if on_off == "on":
			value = ctrl_on
		elif on_off == "off":
			value = ctrl_off
		return value;
	def feedback_range(self, feedback_to):
		if feedback_to['ctrl_type'] == "on/off":
			self.feedback_on_off(feedback_to)
		elif feedback_to['ctrl_type'] == "increment":
			self.feedback_increment(feedback_to)
		elif feedback_to['ctrl_type'] == "decrement":
			self.feedback_decrement(feedback_to)
		control =   eval("self." + str(feedback_to["attached_to"]))
		param =     eval(feedback_to["module"])
		ctrl_min =  feedback_to["minimum"]
		ctrl_max =  feedback_to["maximum"]
		ctrl_type = feedback_to["ctrl_type"]
		default_ctrl_first = 0 
		default_ctrl_last = 127 
		if ctrl_type == "relative":
			crl_reverse = False
			ctrl_first = 0
			ctrl_last = 127
		else:
			crl_reverse = feedback_to["reverse_mode"]
			ctrl_first = feedback_to["enc_first"]
			ctrl_last = feedback_to["enc_second"]
		param_range = param.max - param.min 
		orig_param_range = param.max - param.min
		param_range = ctrl_max * orig_param_range / 100
		ctrl_min_as_val = ctrl_min * orig_param_range / 100
		param_range = param_range - ctrl_min_as_val
		param_value = param.value - ctrl_min_as_val
		
		if orig_param_range == 2.0 and param.min == -1.0:
			param_value = param_value + 1 
		percentage_control_is_at = param_value / param_range * 100
		ctrl_range = ctrl_last - ctrl_first
		percentage_of_ctrl_range = ctrl_range * percentage_control_is_at / 100 + ctrl_first
		percentage_of_ctrl_range = round(percentage_of_ctrl_range,0)
		if crl_reverse == True:
			percentage_of_ctrl_range = ctrl_range - percentage_of_ctrl_range
		self.feedback_handler(feedback_to, percentage_of_ctrl_range)
	def feedback_a_b_crossfade_assign(self, feedback_to):
		assigned_val = eval(str(feedback_to['parent_track']) + ".mixer_device.crossfade_assign")
		if(assigned_val == 0):
			send_val = feedback_to["LED_on"]
		elif(assigned_val == 1):
			send_val = feedback_to["LED_off"]
		elif(assigned_val == 2):
			send_val = feedback_to["LED_assigned_to_b"]
		else: 
			send_val = 0
		self.feedback_handler(feedback_to, send_val)
	def feedback_handler(self, config, send_val):
		send_feedback = False
		if "LED_feedback" in config:
			if config["LED_feedback"] == "custom": 
				if config["LED_feedback_active"] == "1" or config["LED_feedback_active"] == "true": 
					send_feedback = True
			elif hasattr(self, "global_feedback"): 
				if self.global_feedback == "custom":
					if self.global_feedback_active == True: 
						send_feedback = True
				elif hasattr(self, "controller_LED_on") and hasattr(self, "controller_LED_off"):
					send_feedback = True
			if send_feedback == True: 
				if config["LED_feedback"] == "custom":
					for item in config["LED_send_feedback_to_selected"]:
						feedback_control =  eval("self." + str(item))
						feedback_control.send_value(send_val)
				else: 
					control =   eval("self." + str(config["attached_to"]))
					control.send_value(send_val)
			else:
				self.log("feedback_handler says 'not sending led feedback'")
	def sess_highlight_banking_calculate(self, feedback_to, num_of_tracks_scenes, offset_is_at):
		ctrl_first = feedback_to["enc_first"]
		ctrl_last = feedback_to["enc_second"]
		ctrl_range = ctrl_last - ctrl_first
		if feedback_to['ctrl_type'] == "absolute" or feedback_to['ctrl_type'] == "relative":
			percentage_control_is_at = offset_is_at / num_of_tracks_scenes * 100
			velocity_val = ctrl_range * percentage_control_is_at / 100 + ctrl_first
			velocity_val = int(velocity_val) 
		elif feedback_to['ctrl_type'] == "on/off" or feedback_to['ctrl_type'] == "increment":
			if offset_is_at == num_of_tracks_scenes:
				velocity_val = feedback_to["LED_on"]
			else:
				velocity_val = feedback_to["LED_off"]
		elif feedback_to['ctrl_type'] == "decrement":
			if offset_is_at == 0:
				velocity_val = feedback_to["LED_off"]
			else:
				velocity_val = feedback_to["LED_on"]
		if feedback_to['ctrl_type'] == "absolute" and feedback_to["reverse_mode"] == True:
			velocity_val = ctrl_range - velocity_val
		self.feedback_handler(feedback_to, velocity_val)
	def feedback_scroll_mode_selector(self, feedback_to):
		global active_mode
		num_of_tracks_scenes = len(self.modes) - 1
		count = 0
		for mode_num in list(self.modes.values()):
			if mode_num == active_mode:
				offset_is_at = count
				break
			count += 1
		self.sess_highlight_banking_calculate(feedback_to, num_of_tracks_scenes, offset_is_at)
	def feedback_scroll_mode_selector_select(self, feedback_to):
		global active_mode
		mode_to_select = int(feedback_to["func_arg"])
		if int(active_mode) == mode_to_select:
			self.feedback_handler(feedback_to, feedback_to["LED_on"])
		else:
			self.feedback_handler(feedback_to, feedback_to["LED_off"])
	def feedback_param_banking_select(self, feedback_to):
		if type(feedback_to["banking_number"]) == str:
			banking_number = self.get_modifier_value(feedback_to["banking_number"])
		else: 
			banking_number = feedback_to["banking_number"] - 1 
		parent_device_id = feedback_to["parent_device_id"]
		offset_is_at = getattr(self, "device_id_" + str(parent_device_id) + "_active_bank")
		if banking_number == offset_is_at:
			self.feedback_handler(feedback_to, feedback_to["LED_on"])
		else:
			self.feedback_handler(feedback_to, feedback_to["LED_off"])
	def feedback_param_banking(self, feedback_to):
		self.log_message("scroll banking fired")
		parent_device_id = feedback_to["parent_device_id"]
		bank_array = getattr(self, "device_id_" + str(parent_device_id) + "_banks")
		num_of_tracks_scenes = len(bank_array) - 1
		offset_is_at = getattr(self, "device_id_" + str(parent_device_id) + "_active_bank")
		self.sess_highlight_banking_calculate(feedback_to, num_of_tracks_scenes, offset_is_at)
	def feedback_highlight_nav_select(self, feedback_to):
		tracks_or_scenes = feedback_to["tracks_scenes"]
		tracks_scene_num = int(feedback_to["highlight_number"])
		if tracks_or_scenes == "tracks":
			offset_is_at = int(self.selected_track_idx()) - 1
		elif tracks_or_scenes == "scenes":
			offset_is_at = int(self.selected_scene_idx()) - 1
		if tracks_scene_num == offset_is_at:
			self.feedback_handler(feedback_to, feedback_to["LED_on"])
		else:
			self.feedback_handler(feedback_to, feedback_to["LED_off"])
	def feedback_highlight_nav(self, feedback_to):
		tracks_or_scenes = feedback_to["tracks_scenes"]
		if tracks_or_scenes == "tracks":
			offset_is_at = int(self.selected_track_idx()) - 1
			num_of_tracks_scenes = int(len(self.song().tracks)) - 1
		elif tracks_or_scenes == "scenes":
			offset_is_at = int(self.selected_scene_idx()) - 1
			num_of_tracks_scenes = int(len(self.song().scenes)) - 1
		self.sess_highlight_banking_calculate(feedback_to, num_of_tracks_scenes, offset_is_at)
	def feedback_sessbox_nav_select(self, feedback_to):
		try:
			self._session
		except:
			self.show_message("There's no Session Box to select for feedback")
			return
		tracks_scene_num = int(feedback_to["highlight_number"])
		tracks_or_scenes = feedback_to["tracks_scenes"]
		if tracks_or_scenes == "tracks":
			offset_is_at = int(self._session.track_offset())
		elif tracks_or_scenes == "scenes":
			offset_is_at = int(self._session.scene_offset())
		if tracks_scene_num == offset_is_at:
			self.feedback_handler(feedback_to, feedback_to["LED_on"])
		else:
			self.feedback_handler(feedback_to, feedback_to["LED_off"])
	def feedback_sessbox_nav(self, feedback_to):
		try:
			self._session
		except:
			self.show_message("There's no Session Box to scroll for feedback sir.")
			return
		tracks_or_scenes = feedback_to["tracks_scenes"]
		if tracks_or_scenes == "tracks":
			offset_is_at = int(self._session.track_offset())
			num_of_tracks_scenes = int(len(self.song().tracks)) - 1
		elif tracks_or_scenes == "scenes":
			offset_is_at = int(self._session.scene_offset())
			num_of_tracks_scenes = int(len(self.song().scenes)) - 1
		self.sess_highlight_banking_calculate(feedback_to, num_of_tracks_scenes, offset_is_at)
	def feedback_tempo(self, feedback_to):
		control =   eval("self." + str(feedback_to["attached_to"]))
		param =     eval(feedback_to["module"])
		ctrl_min =  feedback_to["minimum"]
		ctrl_max =  feedback_to["maximum"]
		ctrl_type = feedback_to["ctrl_type"]
		ctrl_first = feedback_to["enc_first"]
		ctrl_last = feedback_to["enc_second"]
		default_ctrl_first = 0 
		default_ctrl_last = 127 
		crl_reverse = feedback_to["reverse_mode"]
		param_range = ctrl_max - ctrl_min
		param =     eval(feedback_to["module"] + "." + feedback_to["ui_listener"])
		zero = ctrl_min 
		if param < ctrl_min or param > ctrl_max:
			self.log("tempo is outside ctrl_min / ctrl_max")
		else:
			zerod_param = param - zero 
			percentage_control_is_at = zerod_param / param_range * 100
		ctrl_range = ctrl_last - ctrl_first
		percentage_of_ctrl_range = ctrl_range * percentage_control_is_at / 100 + ctrl_first
		if crl_reverse == True:
			percentage_of_ctrl_range = ctrl_range - percentage_of_ctrl_range
		self.feedback_handler(feedback_to, percentage_of_ctrl_range)
	def mode_device_bank_leds(self, mode_id):
		config_map = "mode_" + str(mode_id) + "_configs_map"
		config_map = getattr(self, config_map)
		for config_name in config_map:
			config = getattr(self, config_name)
			if config["mapping_type"] == "Parameter Bank":
				parent_id = config["parent_json_id"]
				bank_names_array_name = "device_id_" + str(parent_id) + "_banks"
				active_bank_name = "device_id_" + str(parent_id) + "_active_bank"
				bank_names_array = getattr(self, bank_names_array_name)
				active_bank = getattr(self, active_bank_name)
				for index, bank_name in enumerate(bank_names_array):
					if bank_name == config_name:
						if index == active_bank:
							led_on = config["LED_on"]
							self.feedback_handler(config, led_on)
						else: 
							led_off = config["LED_off"]
							self.feedback_handler(config, led_off)
	def bank_led_feedback(self, parent_device_id):
		global active_mode
		device = "device_id_" + str(parent_device_id);
		device_bank_array = getattr(self, device + "_banks")
		active_bank_idx = getattr(self, device + "_active_bank")
		device_bank_params = getattr(self, device + "_bank_parameters_" + str(active_bank_idx))
		for index, val in enumerate(device_bank_array):
			bank_cnfg = getattr(self, val)
			bank_cnfg["LED_feedback"] = "custom"; 
			if index == active_bank_idx:
					if "LED_on" in bank_cnfg:
						led_on = bank_cnfg["LED_on"]
						self.feedback_handler(bank_cnfg, led_on)
			else: 
				if "LED_off" in bank_cnfg:
					led_off = bank_cnfg["LED_off"]
					self.feedback_handler(bank_cnfg, led_off)
		
		remove_mode = getattr(self, "_remove_mode" + active_mode + "_ui_listeners")
		remove_mode()
		activate_mode = getattr(self, "_mode" + active_mode + "_ui_listeners")
		activate_mode()
		for param in device_bank_params:
			fire_param_feedback = getattr(self, param + "_led_listener")
			fire_param_feedback()
	def device_feedback(self, mode_id=None):
		if (mode_id == None):
			global active_mode
			mode_id = active_mode
		config_map = "mode_" + str(mode_id) + "_configs_map"
		config_map = getattr(self, config_map)
		for config_name in config_map:
			config = getattr(self, config_name)
			if "mapping_type" in config and config["mapping_type"] == "Device":
				led_on = config["LED_on"]
				led_off = config["LED_off"]
				try: 
					device = eval(config["module"])
				except:
					self.feedback_handler(config, led_off)
					return
				find = config["module"].find("selected_track")
				if find >= 0: 
					selected_device = self.song().view.selected_track.view.selected_device
					if device == selected_device:
						self.feedback_handler(config, led_on)
					else: 
						self.feedback_handler(config, led_off)
				else:
					for parent_name in config_map:
						parent_config = getattr(self, parent_name)
						if parent_config["json_id"] == config["parent_json_id"]:
							parent_track = parent_config["module"]
							break
					tracks_selected_device = eval(parent_track + ".view.selected_device")
					if device == tracks_selected_device:
						self.feedback_handler(config, led_on)
					else: 
						self.feedback_handler(config, led_off)
	def _on_selected_track_changed(self):
		global active_mode, prev_active_mode, modes
		self.log("selected track changed")
		remove_modex_led_listeners = "_remove_mode" + active_mode + "_led_listeners"
		add_modex_led_listeners = "_mode" + active_mode + "_led_listeners"
		if(hasattr(self, remove_modex_led_listeners)):
			mode_to_call = getattr(self, remove_modex_led_listeners)
			mode_to_call()
		if(hasattr(self, add_modex_led_listeners)):
			mode_to_call = getattr(self, add_modex_led_listeners)
			mode_to_call()
			self.track_feedback()
			self.device_feedback()
		self.refresh_state()
	def track_feedback(self, mode_id=None):
		if (mode_id == None):
			global active_mode
			mode_id = active_mode
		config_map = "mode_" + str(mode_id) + "_configs_map"
		config_map = getattr(self, config_map)
		selected_track = self.song().view.selected_track
		for config_name in config_map:
			config = getattr(self, config_name)
			if "mapping_type" in config and config["mapping_type"] == "Track":
				led_on = config["LED_on"]
				led_off = config["LED_off"]
				try: 
					track = eval(config["module"])
				except:
					self.feedback_handler(config, led_off)
					return
				if track == selected_track:
					self.feedback_handler(config, led_on)
				else: 
					self.feedback_handler(config, led_off)
	def create_clip_slot_map(self):
		num_of_tracks = int(len(self.song().tracks))
		num_of_scenes = int(len(self.song().scenes))
		for track in range(0,num_of_tracks):
			for scene in range(0,num_of_scenes):
				if(not self.song().tracks[track].clip_slots[scene].has_clip_has_listener(self._on_clip_added_removed)):
					try:
						self.song().tracks[track].clip_slots[scene].add_has_clip_listener(self._on_clip_added_removed)
					except: 
						pass
	def _on_clip_added_removed(self):
		global active_mode
		self.log("a clip has been added or removed")
		updated_by = "_on_clip_added_removed"
		self._remove_custom_lom_listeners_handler(active_mode, updated_by)
		self._add_custom_lom_listeners_handler(active_mode, updated_by)
	def _on_tracks_changed(self):
		global active_mode
		self.log("tracks changed")
		updated_by = "_on_tracks_changed"
		self._remove_custom_lom_listeners_handler(active_mode, updated_by)
		self._add_custom_lom_listeners_handler(active_mode, updated_by)
		self.all_track_device_listeners() 
		self.create_clip_slot_map() 
	def _on_scenes_changed(self):
		global active_mode
		self.log("scenes changed")
		updated_by = "_on_scenes_changed"
		self._remove_custom_lom_listeners_handler(active_mode, updated_by)
		self._add_custom_lom_listeners_handler(active_mode, updated_by)
		self.create_clip_slot_map() 
	def _on_devices_changed(self):
		global active_mode, prev_active_mode, modes
		self.log("devices changed")
		updated_by = "_on_devices_changed"
		self._remove_custom_lom_listeners_handler(active_mode, updated_by)
		self._add_custom_lom_listeners_handler(active_mode, updated_by)
		try:
			mode_to_call = getattr(self, "_remove_mode" + active_mode + "_led_listeners")
			mode_to_call()
			mode_to_call = getattr(self, "_mode" + active_mode + "_led_listeners")
			mode_to_call()
		except: 
			pass
	def _on_selected_device_changed(self):
		global active_mode, prev_active_mode, modes
		self.log("selected device changed")
		try:
			mode_to_call = getattr(self, "_remove_mode" + active_mode + "_led_listeners")
			mode_to_call()
			mode_to_call = getattr(self, "_mode" + active_mode + "_led_listeners")
			mode_to_call()
			self.device_feedback()
			self.refresh_state()
		except: 
			pass
	def _on_selected_parameter_changed(self):
		global active_mode
		self.log("selected parameter changed")
		if(hasattr(self.song().view.selected_parameter, "canonical_parent") and hasattr(self.song().view.selected_parameter.canonical_parent, "type")):
			updated_by = "_on_selected_parameter_changed"
			self._remove_custom_lom_listeners_handler(active_mode, updated_by)
			self._add_custom_lom_listeners_handler(active_mode, updated_by)
	def _on_selected_scene_changed(self):
		global active_mode, prev_active_mode, modes
		self.log("selected scene changed")
		remove_modex_led_listeners = "_remove_mode" + active_mode + "_led_listeners"
		add_modex_led_listeners = "_mode" + active_mode + "_led_listeners"
		if(hasattr(self, remove_modex_led_listeners)):
			mode_to_call = getattr(self, remove_modex_led_listeners)
			mode_to_call()
		if(hasattr(self, add_modex_led_listeners)):
			mode_to_call = getattr(self, add_modex_led_listeners)
			mode_to_call()
		self.refresh_state()
	def _all_tracks_listener(self):
		global active_mode, prev_active_mode, modes
		self.log("mode 1 tracks listener")
		mode_to_call = getattr(self, "_remove_mode" + active_mode + "_led_listeners")
		mode_to_call()
		mode_to_call = getattr(self, "_mode" + active_mode + "_led_listeners")
		mode_to_call()
	def all_track_device_listeners(self):
		numtracks = len(self.song().tracks)
		for index in range(numtracks):
			try:
				self.song().tracks[index].view.add_selected_device_listener(self._on_selected_device_changed)
				self.song().tracks[index].add_devices_listener(self._on_devices_changed)
			except:
				pass
		num_returns = len(self.song().return_tracks)
		for index in range(num_returns):
			try:
				self.song().return_tracks[index].view.add_selected_device_listener(self._on_selected_device_changed)
				self.song().return_tracks[index].add_devices_listener(self._on_devices_changed)
			except:
				pass
		try:
			self.song().master_track.view.add_selected_device_listener(self._on_selected_device_changed)
			self.song().master_track.add_devices_listener(self._on_devices_changed)
		except:
			pass
	def _remove_all_track_device_listeners(self):
		numtracks = len(self.song().tracks)
		for index in range(numtracks):
			try:
				self.song().tracks[index].view.remove_selected_device_listener(self._on_selected_device_changed)
				self.song().tracks[index].remove_devices_listener(self._on_devices_changed)
			except:
				pass
		num_returns = len(self.song().return_tracks)
		for index in range(num_returns):
			try:
				self.song().return_tracks[index].view.remove_selected_device_listener(self._on_selected_device_changed)
				self.song().return_tracks[index].remove_devices_listener(self._on_devices_changed)
			except:
				pass
		try:
			self.song().master_track.view.remove_selected_device_listener(self._on_selected_device_changed)
			self.song().master_track.remove_devices_listener(self._on_devices_changed)
		except:
			pass
	################################################
	############# Extra Functions ##################
	################################################
	def scroll_through_devices(self, cnfg):
		NavDirection = Live.Application.Application.View.NavDirection
		if cnfg["ctrl_type"] == "absolute":
			if cnfg["value"] > cnfg["pre_val"]:
				if cnfg["reverse_mode"] is False: 
					goto = "right"
				elif cnfg["reverse_mode"] is True:
					goto = "left"
				times = 1;
			elif cnfg["value"] < cnfg["pre_val"]:
				if cnfg["reverse_mode"] is False: 
					goto = "left"
				elif cnfg["reverse_mode"] is True:
					goto = "right"
				times = 1;
		elif cnfg["ctrl_type"] == "relative":
			if cnfg["enc_first"] == cnfg["value"]:
				goto = "left"
				times = cnfg["steps"];
			elif cnfg["enc_second"] == cnfg["value"]:
				goto = "right"
				times = cnfg["steps"];
		elif cnfg["ctrl_type"] == "on/off": 
			if cnfg["enc_first"] == cnfg["value"]:
					goto = "right"
			elif cnfg["enc_second"] == cnfg["value"]:
					goto = "right"
		elif cnfg["ctrl_type"] == "increment":
			if cnfg["enc_first"] == cnfg["value"]:
				goto = "right"
				times = cnfg["steps"];
		elif cnfg["ctrl_type"] == "decrement":
			if cnfg["enc_first"] == cnfg["value"]:
				goto = "left"
				times = cnfg["steps"];
		if goto == "right":
			for x in range(0, times):
				self._scroll_device_chain(NavDirection.right)
		elif goto == "left":
			for x in range(0, times):
				self._scroll_device_chain(NavDirection.left)
	def _scroll_device_chain(self, direction):
		view = self.application().view
		if not view.is_view_visible('Detail') or not view.is_view_visible('Detail/DeviceChain'):
			view.show_view('Detail')
			view.show_view('Detail/DeviceChain')
		else:
			view.scroll_view(direction, 'Detail/DeviceChain', False)
	def selected_device_idx(self):
		self._device = self.song().view.selected_track.view.selected_device
		return self.tuple_index(self.song().view.selected_track.devices, self._device)
	def selected_track_idx(self):
		self._track = self.song().view.selected_track
		self._track_num = self.tuple_index(self.song().tracks, self._track)
		self._track_num = self._track_num + 1
		return self._track_num
	def selected_scene_idx(self):
		self._scene = self.song().view.selected_scene
		self._scene_num = self.tuple_index(self.song().scenes, self._scene)
		self._scene_num = self._scene_num + 1
		return self._scene_num
	def tuple_index(self, tuple, obj):
		for i in range(0, len(tuple)):
			if (tuple[i] == obj):
				return i
		return(False)
	def select_a_device(self, cnfg):
		parent_track = cnfg["parent_track"]
		device_chain = cnfg["device_chain"]
		chain_selector = "self.song().view.selected_track" + device_chain
		try:
			self.song().view.selected_track = eval(parent_track)
			try:
				self.song().view.select_device(eval(chain_selector))
			except IndexError:
				self.show_message("Device you are trying to select does not exist on track.") 
		except IndexError:
			self.show_message("Track does not exist for the device you are selecting.")
	def a_b_crossfade_assign(self, cnfg):
		assignment_type = cnfg['assignment_type']; 
		if(assignment_type == "Scroll"):
			goto = self.scroll_a_b_assign(cnfg);
			if goto > 2:
				goto = 2
		elif cnfg["enc_first"] == cnfg["value"]:
			if assignment_type == "Select A":
				goto = 0
			elif assignment_type == "Select None":
				goto = 1
			elif assignment_type == "Select B":
				goto = 2
			else:
				goto = 0
		setattr(eval(str(cnfg['parent_track']) + ".mixer_device"), "crossfade_assign", goto)
	def scroll_a_b_assign(self, cnfg):
		should_it_fire = self.should_it_fire(cnfg)
		if(should_it_fire != 1):
			return
		current_assigned_value = eval(str(cnfg['parent_track']) + ".mixer_device.crossfade_assign")
		length = 3
		if cnfg["ctrl_type"] == "absolute":
			divider = (cnfg["enc_second"] - cnfg["enc_first"]) / length
			goto = int(cnfg["value"] / divider) 
			if cnfg["reverse_mode"] is True:
				if(goto >= 2):
					goto = 0
				elif(goto == 0):
					goto = 2
			goto = int(goto)
		elif cnfg["ctrl_type"] == "relative":
			self.log_message("csslog: relative");
			if cnfg["enc_first"] == cnfg["value"] and current_assigned_value > 0:
				goto = current_assigned_value - 1
			elif cnfg["enc_second"] == cnfg["value"] and current_assigned_value < 2:
				goto = current_assigned_value + 1
		elif cnfg["ctrl_type"] == "on/off": 
			if current_assigned_value < 2:
				goto = current_assigned_value + 1
			elif current_assigned_value >= 2:
				goto = 0
		elif cnfg["ctrl_type"] == "increment":
			if current_assigned_value < 2:
				goto = current_assigned_value + 1
			else: 
				goto = current_assigned_value
		elif cnfg["ctrl_type"] == "decrement":
			if current_assigned_value > 0:
				goto = current_assigned_value - 1
			else: 
				goto = current_assigned_value
		return int(goto)
	def scroll_highlight(self, cnfg):
		if cnfg["tracks_scenes"] == "tracks":
			length = len(self.song().tracks) + len(self.song().return_tracks)
			
			selected = self.selected_track_idx() - 1
		elif cnfg["tracks_scenes"] == "scenes":
			length = len(self.song().scenes)
			selected = self.selected_scene_idx() - 1
		else: 
			self.log("scroll_highlight error, tracks_scenes was not set")
		if cnfg["ctrl_type"] == "absolute":
			divider = (cnfg["enc_second"] - cnfg["enc_first"]) / length
			if cnfg["reverse_mode"] is False:
				goto = cnfg["value"] / divider
			elif cnfg["reverse_mode"] is True:
				goto = (divider * length) / cnfg["value"]
			goto = int(goto)
		elif cnfg["ctrl_type"] == "relative":
			if cnfg["enc_first"] == cnfg["value"]:
				goto = selected - cnfg["steps"]
			elif cnfg["enc_second"] == cnfg["value"]:
				goto = selected + cnfg["steps"]
		elif cnfg["ctrl_type"] == "on/off": 
			if cnfg["enc_first"] == cnfg["value"]:
				goto = length
			elif cnfg["enc_second"] == cnfg["value"]:
				goto = 0
		elif cnfg["ctrl_type"] == "increment":
			goto = selected + cnfg["steps"]
		elif cnfg["ctrl_type"] == "decrement":
			goto = selected - cnfg["steps"]
		if goto <= length and goto >= 0 and goto != selected:
			cnfg["highlight_number"] = goto
			self.select_highlight(cnfg)
	def select_sess_offset(self, cnfg):
		try:
			self._session
		except:
			self.show_message("There's no Session Box to select, buddy.")
			return
		tracks_scenes = cnfg["tracks_scenes"]
		track_offset = self._session.track_offset()
		scene_offset = self._session.scene_offset()
		if type(cnfg["highlight_number"]) == str:
			change_to = self.get_modifier_value(cnfg["highlight_number"])
		else: 
			change_to = cnfg["highlight_number"] 
		if tracks_scenes == "tracks":
			track_offset = change_to
		elif tracks_scenes == "scenes":
			scene_offset = change_to
		try:
			self._session.set_offsets(track_offset, scene_offset)
			self._session._reassign_scenes()
			self._set_session_highlight( self._session.track_offset(), self._session.scene_offset(), self._session.width(), self._session.height(), True)
			self.refresh_state()
			self.call_script_reaction(active_mode, None, 'session_box_position')
		except:
			self.show_message("unable to move session box there.")
	def scroll_sess_offset(self, cnfg):
		try:
			self._session
		except:
			self.show_message("There's no Session Box to scroll, buddy.")
			return
		tracks_scenes = cnfg["tracks_scenes"]
		track_offset = self._session.track_offset()
		scene_offset = self._session.scene_offset()
		if cnfg["tracks_scenes"] == "tracks":
			length = len(self.song().tracks)
			selected = track_offset
		elif cnfg["tracks_scenes"] == "scenes":
			length = len(self.song().scenes)
			selected = scene_offset
		else: 
			self.log("scroll_sess_offset error, tracks_scenes was not set")
		if cnfg["ctrl_type"] == "absolute":
			divider = (cnfg["enc_second"] - cnfg["enc_first"]) / length
			goto = cnfg["value"] / divider
			if cnfg["reverse_mode"] is True:
				goto = length - goto
			goto = int(goto)
		elif cnfg["ctrl_type"] == "relative":
			if cnfg["enc_first"] == cnfg["value"]:
				goto = selected - cnfg["steps"]
			elif cnfg["enc_second"] == cnfg["value"]:
				goto = selected + cnfg["steps"]
		elif cnfg["ctrl_type"] == "on/off": 
			if cnfg["enc_first"] == cnfg["value"] or cnfg["enc_second"] == cnfg["value"]:
				if selected != 0 and selected != length - 1:
					goto = length - 1
				elif selected == 0:
					goto = length - 1
				else: 
					goto = 0        
		elif cnfg["ctrl_type"] == "increment":
			goto = selected + cnfg["steps"]
		elif cnfg["ctrl_type"] == "decrement":
			goto = selected - cnfg["steps"]
		if(goto < 0):
			goto = 0
		if cnfg["tracks_scenes"] == "tracks":
			track_offset = goto
		elif cnfg["tracks_scenes"] == "scenes":
			scene_offset = goto
		try:
			self._session.set_offsets(track_offset, scene_offset)
			self._session._reassign_scenes()
			self._set_session_highlight( self._session.track_offset(), self._session.scene_offset(), self._session.width(), self._session.height(), True)
			self.refresh_state()
			self.call_script_reaction(active_mode, None, 'session_box_position')
		except:
			self.show_message("unable to move session box there.")
	def get_tracks_array(self):
		tracks_array = []
		count = 0
		for index in range(len(self.song().tracks)):
			tracks_array.append(self.song().tracks[count])
			count = count+1
		count = 0
		for index in range(len(self.song().return_tracks)): 
			tracks_array.append(self.song().return_tracks[count])
			count = count+1
		tracks_array.append(self.song().master_track)
		return tracks_array
	def select_highlight(self, cnfg):
		tracks_scenes = cnfg["tracks_scenes"]
		if type(cnfg["highlight_number"]) == str:
			change_to = self.get_modifier_value(cnfg["highlight_number"])
		else: 
			change_to = cnfg["highlight_number"] 
		
		if tracks_scenes == "tracks":
			num_of_tracks_scenes = len(self.song().tracks) + len(self.song().return_tracks) + 1
		elif tracks_scenes == "scenes":
			num_of_tracks_scenes = len(self.song().scenes)
		if num_of_tracks_scenes >= change_to + 1:
			if tracks_scenes == "tracks":
				all_tracks_arr = self.get_tracks_array()
				self.song().view.selected_track = all_tracks_arr[change_to]
			elif tracks_scenes == "scenes":
				self.song().view.selected_scene = self.song().scenes[change_to]
		else: 
			self.show_message("Your Session doesn't have " + str(change_to + 1) + " " + tracks_scenes)
	def scroll_active_device_bank(self, cnfg):
		device_id = cnfg["parent_device_id"]
		device = "device_id_" + str(device_id);
		active_bank = getattr(self, device + "_active_bank")
		banks = getattr(self, device + "_banks")
		length = len(banks) - 1
		if cnfg["ctrl_type"] == "absolute":
			divider = (cnfg["enc_second"] - cnfg["enc_first"]) / length
			if cnfg["reverse_mode"] is False:
				goto = cnfg["value"] / divider
			elif cnfg["reverse_mode"] is True:
				goto = (divider * length) / cnfg["value"]
			goto = int(goto)
		elif cnfg["ctrl_type"] == "relative":
			if cnfg["enc_first"] == cnfg["value"]:
				goto = active_bank - 1
			elif cnfg["enc_second"] == cnfg["value"]:
				goto = active_bank + 1
		elif cnfg["ctrl_type"] == "on/off":
			if cnfg["switch_type"] == "toggle": 
				if cnfg["enc_first"] == cnfg["value"]:
					goto = length
				elif cnfg["enc_second"] == cnfg["value"]:
					goto = 0
			elif active_bank == length:
				goto = 0
			else:  
				goto = length
		elif cnfg["ctrl_type"] == "increment":
				goto = active_bank + 1
		elif cnfg["ctrl_type"] == "decrement":
				goto = active_bank - 1
		if goto <= length and goto >= 0 and goto != active_bank:
			cnfg["banking_number"] = goto + 1 
			self.change_active_device_bank(cnfg)
	def change_active_device_bank(self, cnfg):
		global active_mode
		device_id = cnfg["parent_device_id"]
		if type(cnfg["banking_number"]) == str:
			change_to_bank = self.get_modifier_value(cnfg["banking_number"])
		else: 
			change_to_bank = cnfg["banking_number"] - 1
		device = "device_id_" + str(device_id);
		bank_names = getattr(self, device + "_bank_names")
		length = len(bank_names) - 1; 
		if change_to_bank <= length:
			setattr(self, device + "_active_bank", change_to_bank)
			self.bank_led_feedback(cnfg["parent_json_id"]);
			self.show_message("changed active bank to: " + bank_names[change_to_bank])
		elif change_to_bank > length:
			self.show_message("device does not have " + str(change_to_bank + 1) + " parameter banks set")
		fire_all_mode_feedback = getattr(self, "_mode" + active_mode + "_fire_all_feedback")
		fire_all_mode_feedback()
	def session_box(self, num_tracks, num_scenes, track_offset, scene_offset, clips, stop_all, stop_tracks, scene_launch, feedbackArr, combination_mode):
		self._session = SessionComponent(num_tracks, num_scenes)
		self._session.set_offsets(track_offset, scene_offset)
		self._session.set_highlighting_callback(self._set_session_highlight)
		self._session.add_offset_listener(self._on_session_offset_changes, identify_sender= False)
		self._session._reassign_scenes()
		self._set_session_highlight( self._session.track_offset(), self._session.scene_offset(), self._session.width(), self._session.height(), True)
		if clips: 
			self._grid = ButtonMatrixElement(rows=[clips[(index*num_tracks):(index*num_tracks)+num_tracks] for index in range(num_scenes)])
			self._session.set_clip_launch_buttons(self._grid)
		if stop_all:
			self._session.set_stop_all_clips_button(stop_all)
		if stop_tracks:
			self._session.set_stop_track_clip_buttons(tuple(stop_tracks))
		if scene_launch:
			scene_launch_buttons = ButtonMatrixElement(rows=[scene_launch])
			self._session.set_scene_launch_buttons(scene_launch_buttons)
			self._session.set_stop_clip_triggered_value(feedbackArr["StopClipTriggered"])
			self._session.set_stop_clip_value(feedbackArr["StopClip"])
		for scene_index in range(num_scenes):
			scene = self._session.scene(scene_index)
			scene.set_scene_value(feedbackArr["Scene"])
			scene.set_no_scene_value(feedbackArr["NoScene"])
			scene.set_triggered_value(feedbackArr["SceneTriggered"])
			for track_index in range(num_tracks):
				clip_slot = scene.clip_slot(track_index)
				clip_slot.set_triggered_to_play_value(feedbackArr["ClipTriggeredPlay"])
				clip_slot.set_triggered_to_record_value(feedbackArr["ClipTriggeredRecord"])
				clip_slot.set_record_button_value(feedbackArr["RecordButton"])
				clip_slot.set_stopped_value(feedbackArr["ClipStopped"])
				clip_slot.set_started_value(feedbackArr["ClipStarted"])
				clip_slot.set_recording_value(feedbackArr["ClipRecording"])
			for index in range(len(stop_tracks)):
				stop_track_button = stop_tracks[index]
				if feedbackArr["StopTrackPlaying"] and feedbackArr["StopTrackStopped"]:
					stop_track_button.set_on_off_values(feedbackArr["StopTrackPlaying"], feedbackArr["StopTrackStopped"])
			if stop_all:
				if feedbackArr["StopAllOn"] and feedbackArr["StopAllOff"]:
					stop_all.set_on_off_values(feedbackArr["StopAllOn"], feedbackArr["StopAllOff"])
		if combination_mode == "on":
			self._session._link()
		self.refresh_state()
	def _on_session_offset_changes(self):
		global active_mode
		updated_by = "_on_session_offset_changes"
		self._remove_custom_lom_listeners_handler(active_mode, updated_by)
		self._add_custom_lom_listeners_handler(active_mode, updated_by)
		self.log("sessionbox offset changed")
		try:
			remove_mode = getattr(self, "_remove_mode" + active_mode + "_led_listeners")
			remove_mode()
			activate_mode = getattr(self, "_mode" + active_mode + "_led_listeners")
			activate_mode()
		except:
			self.log("_on_session_offset_changes: could not remove / add led_listeners")
			return;
	def remove_session_box(self, combination_mode): 
		if hasattr(self, "_session"):
			self.current_track_offset = self._session._track_offset
			self.current_scene_offset = self._session._scene_offset
			self._session.set_clip_launch_buttons(None)
			self._set_session_highlight(-1, -1, -1, -1, False)
			self._session.set_stop_all_clips_button(None)
			self._session.set_stop_track_clip_buttons(None)
			self._session.set_scene_launch_buttons(None)
			if combination_mode == "on":
				self._session._unlink()
			self._session = None
	def scroll_modes(self, cnfg):
		controller = getattr(self, cnfg["attached_to"])
		cnfg["value"] = controller.cur_val 
		if cnfg["ctrl_type"] == "absolute":
			divider = (cnfg["enc_second"] - cnfg["enc_first"]) / (len(self.modes) - 1)
			if cnfg["reverse_mode"] is False:
				goto = cnfg["value"] / divider
			elif cnfg["reverse_mode"] is True:
				length = len(self.modes) - 1
				goto = (divider * length) / cnfg["value"]
			goto = int(goto)
		elif cnfg["ctrl_type"] == "relative":
			if cnfg["enc_first"] == cnfg["value"]:
				goto = self.key_num - 1
			elif cnfg["enc_second"] == cnfg["value"]:
				goto = self.key_num + 1
		elif cnfg["ctrl_type"] == "on/off": 
			if cnfg["enc_first"] == cnfg["value"]:
				goto = len(self.modes) - 1
			elif cnfg["enc_second"] == cnfg["value"]:
				goto = 0
		elif cnfg["ctrl_type"] == "increment":
			if cnfg["enc_first"] == cnfg["value"]:
				goto = self.key_num + 1
		elif cnfg["ctrl_type"] == "decrement":
			if cnfg["enc_first"] == cnfg["value"]:
				goto = self.key_num - 1
		if goto <= len(self.modes) and goto >= 0 and active_mode != self.modes[goto]:
			self.set_active_mode(self.modes[goto])
	def listening_to_tracks(self):
		global active_mode
		self.remove_listening_to_tracks()
		for index in range(len(self.song().tracks)):
			_track = self.song().tracks[index]
			if _track.can_be_armed and hasattr(self, "_mode" + active_mode + "_arm_listener"):
				_track.add_arm_listener(getattr(self, "_mode" + active_mode + "_arm_listener"))
			if hasattr(self, "_mode" + active_mode + "_mute_listener"):
				_track.add_mute_listener(getattr(self, "_mode" + active_mode + "_mute_listener"))
			if hasattr(self, "_mode" + active_mode + "_solo_listener"):
				_track.add_solo_listener(getattr(self, "_mode" + active_mode + "_solo_listener"))
			if hasattr(self, "_mode" + active_mode + "_volume_listener"):
				_track.mixer_device.volume.add_value_listener(getattr(self, "_mode" + active_mode + "_volume_listener"))
			if hasattr(self, "_mode" + active_mode + "_panning_listener"):
				_track.mixer_device.panning.add_value_listener(getattr(self, "_mode" + active_mode + "_panning_listener"))
			if hasattr(self, "_mode" + active_mode + "_send_listener"):
				for send_index in range(len(_track.mixer_device.sends)):
					_track.mixer_device.sends[send_index].add_value_listener(getattr(self, "_mode" + active_mode + "_send_listener"))
		for index in range(len(self.song().return_tracks)):
			_return_track = self.song().return_tracks[index]
			if hasattr(self, "_mode" + active_mode + "_mute_listener"):
				_return_track.add_mute_listener(getattr(self, "_mode" + active_mode + "_mute_listener"))
			if hasattr(self, "_mode" + active_mode + "_solo_listener"):
				_return_track.add_solo_listener(getattr(self, "_mode" + active_mode + "_solo_listener"))
			if hasattr(self, "_mode" + active_mode + "_volume_listener"):
				_return_track.mixer_device.volume.add_value_listener(getattr(self, "_mode" + active_mode + "_volume_listener"))
			if hasattr(self, "_mode" + active_mode + "_panning_listener"):
				_return_track.mixer_device.panning.add_value_listener(getattr(self, "_mode" + active_mode + "_panning_listener"))
			if hasattr(self, "_mode" + active_mode + "_send_listener"):
				for send_index in range(len(_return_track.mixer_device.sends)):
					_return_track.mixer_device.sends[send_index].add_value_listener(getattr(self, "_mode" + active_mode + "_send_listener"))
		_master = self.song().master_track
		if hasattr(self, "_mode" + active_mode + "_volume_listener"):
			_master.mixer_device.volume.add_value_listener(getattr(self, "_mode" + active_mode + "_volume_listener"))
		if hasattr(self, "_mode" + active_mode + "_panning_listener"):
			_master.mixer_device.panning.add_value_listener(getattr(self, "_mode" + active_mode + "_panning_listener"))
	def remove_listening_to_tracks(self):
		global active_mode
		for index in range(len(self.song().tracks)):
			_track = self.song().tracks[index]
			if hasattr(self, "_mode" + active_mode + "_arm_listener"):
				if _track.arm_has_listener(getattr(self, "_mode" + active_mode + "_arm_listener")):
					_track.remove_arm_listener(getattr(self, "_mode" + active_mode + "_arm_listener"))
			if hasattr(self, "_mode" + active_mode + "_mute_listener"):
				if _track.mute_has_listener(getattr(self, "_mode" + active_mode + "_mute_listener")):
					_track.remove_mute_listener(getattr(self, "_mode" + active_mode + "_mute_listener"))
			if hasattr(self, "_mode" + active_mode + "_solo_listener"):
				if _track.solo_has_listener(getattr(self, "_mode" + active_mode + "_solo_listener")):
					_track.remove_solo_listener(getattr(self, "_mode" + active_mode + "_solo_listener"))
			if hasattr(self, "_mode" + active_mode + "_volume_listener"):
				if _track.mixer_device.volume.value_has_listener(getattr(self, "_mode" + active_mode + "_volume_listener")):
					_track.mixer_device.volume.remove_value_listener(getattr(self, "_mode" + active_mode + "_volume_listener"))
			if hasattr(self, "_mode" + active_mode + "_panning_listener"):
				if _track.mixer_device.panning.value_has_listener(getattr(self, "_mode" + active_mode + "_panning_listener")):
					_track.mixer_device.panning.remove_value_listener(getattr(self, "_mode" + active_mode + "_panning_listener"))
			if hasattr(self, "_mode" + active_mode + "_send_listener"):
				for send_index in range(len(_track.mixer_device.sends)):
					if _track.mixer_device.sends[send_index].value_has_listener(getattr(self, "_mode" + active_mode + "_send_listener")):
						_track.mixer_device.sends[send_index].remove_value_listener(getattr(self, "_mode" + active_mode + "_send_listener"))
		for index in range(len(self.song().return_tracks)):
			_return_track = self.song().return_tracks[index]
			if hasattr(self, "_mode" + active_mode + "_mute_listener"):
				if _return_track.mute_has_listener(getattr(self, "_mode" + active_mode + "_mute_listener")):
					_return_track.remove_mute_listener(getattr(self, "_mode" + active_mode + "_mute_listener"))
			if hasattr(self, "_mode" + active_mode + "_solo_listener"):
				if _return_track.solo_has_listener(getattr(self, "_mode" + active_mode + "_solo_listener")):
					_return_track.remove_solo_listener(getattr(self, "_mode" + active_mode + "_solo_listener"))
			if hasattr(self, "_mode" + active_mode + "_volume_listener"):
				if _return_track.mixer_device.volume.value_has_listener(getattr(self, "_mode" + active_mode + "_volume_listener")):
					_return_track.mixer_device.volume.remove_value_listener(getattr(self, "_mode" + active_mode + "_volume_listener"))
			if hasattr(self, "_mode" + active_mode + "_panning_listener"):
				if _return_track.mixer_device.panning.value_has_listener(getattr(self, "_mode" + active_mode + "_panning_listener")):
					_return_track.mixer_device.panning.remove_value_listener(getattr(self, "_mode" + active_mode + "_panning_listener"))
			if hasattr(self, "_mode" + active_mode + "_send_listener"):
				for send_index in range(len(_return_track.mixer_device.sends)):
					if _return_track.mixer_device.sends[send_index].value_has_listener(getattr(self, "_mode" + active_mode + "_send_listener")):
						_return_track.mixer_device.sends[send_index].remove_value_listener(getattr(self, "_mode" + active_mode + "_send_listener"))
		_master = self.song().master_track
		if hasattr(self, "_mode" + active_mode + "_volume_listener"):
			if _master.mixer_device.volume.value_has_listener(getattr(self, "_mode" + active_mode + "_volume_listener")):
				_master.mixer_device.volume.remove_value_listener(getattr(self, "_mode" + active_mode + "_volume_listener"))
		if hasattr(self, "_mode" + active_mode + "_panning_listener"):
			if _master.mixer_device.panning.value_has_listener(getattr(self, "_mode" + active_mode + "_panning_listener")):
				_master.mixer_device.panning.remove_value_listener(getattr(self, "_mode" + active_mode + "_panning_listener"))
	def set_active_mode(self, activate_new_mode):
		global active_mode, prev_active_mode, modes
		for number, mode_id in list(self.modes.items()):
			if mode_id == activate_new_mode:
				self.key_num = mode_id
		if(activate_new_mode == "Previous Mode"):
			if 'prev_active_mode' not in globals():
				self.show_message("No previous mode is set yet.")
			else:
				remove_mode = getattr(self, "_remove_mode" + active_mode)
				remove_mode()
				activate_new_mode = prev_active_mode
				prev_active_mode = active_mode
				self.call_script_reaction(prev_active_mode, None, 'mode_is_deactivated') 
				active_mode = activate_new_mode
				mode_to_call = getattr(self, "_mode" + activate_new_mode)
				mode_to_call()
				self.call_script_reaction(activate_new_mode, None, 'mode_is_activated') 
		else:
			if 'active_mode' in globals():
				remove_mode = getattr(self, "_remove_mode" + active_mode)
				remove_mode()
				prev_active_mode = active_mode
				self.call_script_reaction(prev_active_mode, None, 'mode_is_deactivated') 
			active_mode = activate_new_mode 
			mode_to_call = getattr(self, "_mode" + activate_new_mode)
			mode_to_call()
			self.call_script_reaction(activate_new_mode, None, 'mode_is_activated') 
	def target_by_name(self, target_list, name):
		matches = [t for t in target_list if t.display_name == name]
		if matches:
			return matches[0]
		return
	def _add_custom_lom_listeners_handler(self, mode_number, updated_by=False):
		self.log("custom lom listeners refreshed")
		name_string = "_mode" + str(mode_number) + "_custom_lom_listeners"
		if hasattr(self, name_string):
			try:
				mode_to_call = getattr(self, name_string)
				mode_to_call(updated_by)  
			except:
				self.log_message("csslog: unable to run " + name_string)
				pass
	def _remove_custom_lom_listeners_handler(self, mode_number, updated_by=False):
		name_string = "_remove_mode" + str(mode_number) + "_custom_lom_listeners"
		if hasattr(self, name_string):
			try:
				mode_to_call = getattr(self, name_string)
				mode_to_call(updated_by)
			except:
				self.log_message("csslog: unable to run " + name_string)
				pass
	def get_modifier_value(self, mod_name):
		return self.modifiers[mod_name]["value"]
	def set_modifier_value(self, mod_name, contents):
		global active_mode
		self.modifiers[mod_name]["value"] = contents 
		self.call_script_reaction(active_mode, mod_name, "modifier_was_updated")
	def call_script_reaction(self, mode_id, param2, reaction_name):
		one = "";   
		two = "";   
		three = ""; 
		if(mode_id!=None):
			one = "_mode_" + str(mode_id)
		if(param2!=None):
			two = "_" + str(param2)
		if(reaction_name!=None):
			three = "_" + str(reaction_name)
		reaction_method = one + two + three
		if hasattr(self, reaction_method):
			getattr(self, reaction_method)()
	def disconnect(self):
		self.call_script_reaction(None, None, 'script_is_disconnected')
		super(AudioSwift_Mixer, self).disconnect()
